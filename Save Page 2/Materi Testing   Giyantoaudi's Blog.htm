<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- saved from url=(0042)http://giyantoaudi.wordpress.com/motivasi/ -->
<html xmlns="http://www.w3.org/1999/xhtml" lang="id"><!--<![endif]--><head profile="http://gmpg.org/xfn/11"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Materi Testing | Giyantoaudi's Blog</title>
<link rel="pingback" href="http://giyantoaudi.wordpress.com/xmlrpc.php">
<link rel="alternate" type="application/rss+xml" title="Giyantoaudi&#39;s Blog » Feed" href="http://giyantoaudi.wordpress.com/feed/">
<link rel="alternate" type="application/rss+xml" title="Giyantoaudi&#39;s Blog » Umpan Komentar" href="http://giyantoaudi.wordpress.com/comments/feed/">
<script type="text/javascript">
/* <![CDATA[ */
function addLoadEvent(func){var oldonload=window.onload;if(typeof window.onload!='function'){window.onload=func;}else{window.onload=function(){oldonload();func();}}}
/* ]]> */
</script>
<link rel="stylesheet" id="all-css-0" href="http://s2.wp.com/_static/??-eJx9UNtOwzAM/SGKxTYGPCC+JU08150TR42rqn9PWoS4DPLmY52bDUvuvCbDZBDnLstMnAqUyIJrnnREbz/RvS/lDv6WCV+xwIiWnb92O7qh96L0JVAiDDpbd1ERXWDhQNjM4HThxLaCDRhrWp57CEx0bIm8Tlj3MTvbGBEDO5SqT82smM+fqm0c6lW3B/3uAcVWwZbthNsT6khQWd/gf97DCUi0d9Jy/Xhd2S1JNUzowt72Lb4+HF/Oz0+Hw+NpfAd04bpk" type="text/css" media="all">
<link rel="stylesheet" id="print-css-0" href="./Materi Testing   Giyantoaudi's Blog_files/global-print.css" type="text/css" media="print">
<script type="text/javascript">
/* <![CDATA[ */
var LoggedOutFollow = {"invalid_email":"Langganan Anda tidak berhasil. Silakan coba lagi dengan alamat email yang baru."};
/* ]]> */
</script>
<script type="text/javascript" src="./Materi Testing   Giyantoaudi's Blog_files/saved_resource"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://giyantoaudi.wordpress.com/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://giyantoaudi.wordpress.com/wp-includes/wlwmanifest.xml"> 
<link rel="prev" title="Materi Kuliah" href="http://giyantoaudi.wordpress.com/materi-kuliah/">
<link rel="next" title="Profile" href="http://giyantoaudi.wordpress.com/profile/">
<meta name="generator" content="WordPress.com">
<link rel="canonical" href="./Materi Testing   Giyantoaudi's Blog_files/Materi Testing   Giyantoaudi's Blog.htm">
<link rel="shortlink" href="http://wp.me/Pxd2R-2u">
<link rel="alternate" type="application/json+oembed" href="https://public-api.wordpress.com/oembed/1.0/?format=json&url=http%3A%2F%2Fgiyantoaudi.wordpress.com%2Fmotivasi%2F&for=wpcom-auto-discovery"><link rel="alternate" type="application/xml+oembed" href="https://public-api.wordpress.com/oembed/1.0/?format=xml&url=http%3A%2F%2Fgiyantoaudi.wordpress.com%2Fmotivasi%2F&for=wpcom-auto-discovery">
<!-- Jetpack Open Graph Tags -->
<meta property="og:type" content="article">
<meta property="og:title" content="Materi Testing">
<meta property="og:url" content="http://giyantoaudi.wordpress.com/motivasi/">
<meta property="og:description" content="Terminologi Software : seluruh komponen pengolahan data yang dapat membantu memecahkan masalah diluar dari perangkat hardware yang meliputi system design, program dan prosedur. Beberapa gambaran um...">
<meta property="article:published_time" content="2009-10-20T13:15:14+00:00">
<meta property="article:modified_time" content="2011-02-12T02:20:52+00:00">
<meta property="article:author" content="http://giyantoaudi.wordpress.com/author/giyantoaudi/">
<meta property="og:site_name" content="Giyantoaudi&#39;s Blog">
<meta property="og:image" content="http://wordpress.com/i/blank.jpg?m=1383295312g">
<meta name="twitter:site" content="@wordpressdotcom">
<meta name="twitter:card" content="summary">
<meta property="fb:app_id" content="249643311490">
<meta property="article:publisher" content="https://www.facebook.com/WordPresscom">
<link rel="shortcut icon" type="image/x-icon" href="http://s2.wp.com/i/favicon.ico?m=1311975824g" sizes="16x16 24x24 32x32 48x48">
<link rel="icon" type="image/x-icon" href="http://s2.wp.com/i/favicon.ico?m=1311975824g" sizes="16x16 24x24 32x32 48x48">
<link rel="apple-touch-icon-precomposed" href="http://s0.wp.com/i/webclip.png?m=1391188133g">
<link rel="openid.server" href="http://giyantoaudi.wordpress.com/?openidserver=1">
<link rel="openid.delegate" href="http://giyantoaudi.wordpress.com/">
<link rel="search" type="application/opensearchdescription+xml" href="http://giyantoaudi.wordpress.com/osd.xml" title="Giyantoaudi&#39;s Blog">
<link rel="search" type="application/opensearchdescription+xml" href="http://wordpress.com/opensearch.xml" title="WordPress.com">
<meta name="application-name" content="Giyantoaudi&#39;s Blog"><meta name="msapplication-window" content="width=device-width;height=device-height"><meta name="msapplication-tooltip" content="Just another WordPress.com weblog"><meta name="msapplication-task" content="name=Berlangganan;action-uri=http://giyantoaudi.wordpress.com/feed/;icon-uri=http://s2.wp.com/i/favicon.ico"><meta name="msapplication-task" content="name=Sign up for a free blog;action-uri=http://wordpress.com/signup/;icon-uri=http://s2.wp.com/i/favicon.ico"><meta name="msapplication-task" content="name=Dukungan WordPress.com;action-uri=http://support.wordpress.com/;icon-uri=http://s2.wp.com/i/favicon.ico"><meta name="msapplication-task" content="name=Forum WordPress.com;action-uri=http://forums.wordpress.com/;icon-uri=http://s2.wp.com/i/favicon.ico"><meta name="title" content="Materi Testing | Giyantoaudi&#39;s Blog di WordPress.com">
<meta name="description" content="Terminologi Software : seluruh komponen pengolahan data yang dapat membantu memecahkan masalah diluar dari perangkat hardware yang meliputi system design, program dan prosedur. Beberapa gambaran umum tentang perangkat lunak antara lain  : 1)       Perintah (program computer) yang bila dieksekusi memberikan fungsi dan unjuk kerja seperti yang diinginkan. 2)       Struktur data yang memungkinkan program memanipulasi informasi…">
<style type="text/css">
#header h1 a, #header .description {
display: none;
}
</style>
<style type="text/css" id="custom-background-css">
body.custom-background { background-image: url('http://giyantoaudi.files.wordpress.com/2011/09/9lorpager.jpg'); background-repeat: repeat; background-position: top center; background-attachment: scroll; }
</style>
<style type="text/css" id="syntaxhighlighteranchor"></style>
<link rel="stylesheet" type="text/css" id="gravatar-card-css" href="./Materi Testing   Giyantoaudi's Blog_files/hovercard.css"><link rel="stylesheet" type="text/css" id="gravatar-card-services-css" href="./Materi Testing   Giyantoaudi's Blog_files/services.css"><script type="text/javascript" async="" src="http://r.skimresources.com/api/?callback=skimlinksApplyHandlers&data=%7B%22pubcode%22%3A%22725X584219%22%2C%22domains%22%3A%5B%22edit.yahoo.com%22%2C%22giyantoaudi.files.wordpress.com%22%2C%22widgia.com%22%2C%22whos.amung.us%22%2C%22mail.google.com%22%2C%22login.yahoo.com%22%2C%22google.co.id%22%2C%22didiksetiyadi.com%22%2C%22sites.google.com%22%2C%22firstmedia.com%22%2C%22id.wordpress.com%22%2C%22theme.wordpress.com%22%5D%2C%22page%22%3A%22http%3A%2F%2Fgiyantoaudi.wordpress.com%2Fmotivasi%2F%22%7D"></script></head>
<body class="page page-id-154 page-template-default custom-background mp6 no-svg highlander-enabled highlander-light" style=""><div id="container">

<div id="header">

	<div id="menu">
		<ul class="menu">
	<li class="page_item"><a href="http://giyantoaudi.wordpress.com/" sl-processed="1">Beranda</a></li>
	<li class="page_item page-item-118"><a href="http://giyantoaudi.wordpress.com/materi-kuliah/" sl-processed="1">Materi Kuliah</a></li>
<li class="page_item page-item-154 current_page_item"><a href="./Materi Testing   Giyantoaudi's Blog_files/Materi Testing   Giyantoaudi's Blog.htm" sl-processed="1">Materi Testing</a></li>
<li class="page_item page-item-218"><a href="http://giyantoaudi.wordpress.com/profile/" sl-processed="1">Profile</a></li>
</ul>
	</div>

	<div id="header-box">
	<div id="header-image">
		<img src="http://giyantoaudi.files.wordpress.com/2009/10/cropped-sany06922.jpg" alt="">
	</div>
	<div id="header-overlay">
		<img src="./Materi Testing   Giyantoaudi's Blog_files/bg_header_overlay.png" alt="">
	</div>

	<div id="pagetitle">
		<h1><a href="http://giyantoaudi.wordpress.com/" title="Giyantoaudi&#39;s Blog" sl-processed="1">Giyantoaudi's Blog</a></h1>
	</div>

	<div id="syndication">
		<a href="http://giyantoaudi.wordpress.com/feed/" title="Sindikasikan situs ini menggunakan RSS" class="feed" sl-processed="1"><abbr title="Really Simple Syndication">RSS</abbr> Entri</a> | <a href="http://giyantoaudi.wordpress.com/comments/feed/" title="Syndicate comments using RSS" sl-processed="1">Comments RSS</a>
	</div>
	<div id="searchbox">
		<form method="get" id="searchform" action="http://giyantoaudi.wordpress.com/">
<div>
	<input type="text" value="" name="s" id="s">
	<input type="submit" id="searchsubmit" value="Cari">
</div>
</form>	</div>
	</div>
</div>

<div class="pagewrapper"><div id="page">

<!-- Start Obar -->

	<div class="obar">
<ul>

<li id="text-4" class="widget widget_text">			<div class="textwidget"><a href="http://edit.yahoo.com/config/send_webmesg?.target=audi655y&.src=pg%E2%80%9D" sl-processed="1"><img src="http://opi.yahoo.com/online?u=audi655&m=g&t=2&l=us%E2%80%9D" border="”0″" alt=""></a></div>
		</li>
<li id="text-5" class="widget widget_text">			<div class="textwidget"><a href="http://giyantoaudi.files.wordpress.com/2009/12/fm.jpg" sl-processed="1"><img class="aligncenter size-full wp-image-230" title="fm" src="http://giyantoaudi.files.wordpress.com/2009/12/fm.jpg" alt="" width="170" height="92"></a></div>
		</li>
<li id="text-8" class="widget widget_text">			<div class="textwidget"><img style="visibility:hidden;width:0;height:0;" src="http://counters.gigya.com/wildfire/IMP/CXNID=2000002.0NXC/bHQ9MTI2MTQ1NDEyNjc4MSZwdD*xMjYxNDU*MTQ2MDAwJnA9MjIzMDUyJmQ9Jm49d29yZHByZXNzJmc9MSZvPWM2NmYwY2JmMTg2ZjRkMjJiNGQ1OGNjOGExOWVkZDI3Jm9mPTA=.gif" border="0" alt="" width="0" height="0"><iframe frameborder="0" width="174" height="174" src="./Materi Testing   Giyantoaudi's Blog_files/saved_resource(3).htm" id="wpcom-iframe-21d53efeca225e23c8b972e76437a606"></iframe>
<a href="http://widgia.com/" target="_blank" sl-processed="1">Powered by Widgia.com</a></div>
		</li>
<li id="meta-3" class="widget widget_meta"><h2 class="widgettitle">Meta</h2>
			<ul>
			<li><a href="http://wordpress.com/signup/?ref=wplogin" sl-processed="1">Daftar</a></li>			<li><a href="http://giyantoaudi.wordpress.com/wp-login.php" sl-processed="1">Masuk log</a></li>
			<li><a href="http://giyantoaudi.wordpress.com/feed/" title="Sindikasikan situs ini menggunakan RSS 2.0" sl-processed="1"><abbr title="Really Simple Syndication">RSS</abbr> Entri</a></li>
			<li><a href="http://giyantoaudi.wordpress.com/comments/feed/" title="Komentar-komentar terakhir pada seluruh tulisan dalam RSS" sl-processed="1"><abbr title="Really Simple Syndication">RSS</abbr> Komentar</a></li>
<li><a href="http://wordpress.com/" title="Didukung oleh WordPress, state-of-the-art semantic personal publishing platform." sl-processed="1">WordPress.com</a></li>			</ul>
</li>
<li id="text-3" class="widget widget_text"><h2 class="widgettitle">Tamu On Line</h2>
			<div class="textwidget"><a href="http://whos.amung.us/stats/z5d0vsyhyuhh/%E2%80%9D" sl-processed="1"><img src="http://whos.amung.us/cwidget/z5d0vsyhyuhh/ffc20e000000.png%E2%80%9D" width="”81″" height="”29″" border="”0″" title="”Click"></a></div>
		</li>

</ul>
	</div>

<!-- End Obar -->
	<div class="wrapper"><!-- This wrapper class appears only on Page and Single Post pages. -->
	<div class="narrowcolumnwrapper"><div class="narrowcolumn">

		<div class="content">

			
			<div class="post-154 page type-page status-publish hentry post" id="post-154">

				<h2><a href="./Materi Testing   Giyantoaudi's Blog_files/Materi Testing   Giyantoaudi's Blog.htm" rel="bookmark" title="Materi Testing" sl-processed="1">Materi Testing</a></h2>

				<div class="entry">

					<p><strong>Terminologi </strong></p>
<p><strong><em>Software </em></strong> <strong>:</strong> seluruh komponen pengolahan data yang dapat membantu memecahkan masalah diluar dari perangkat hardware yang meliputi system design, program dan prosedur.</p>
<p>Beberapa gambaran umum tentang perangkat lunak antara lain&nbsp; :</p>
<p>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Perintah (program computer) yang bila dieksekusi memberikan fungsi dan unjuk kerja seperti yang diinginkan.</p>
<p>2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Struktur data yang memungkinkan program memanipulasi informasi secara proporsional.</p>
<p>3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Dokumen yang menggambarkan operasi dan kegunaan program.</p>
<p><strong><span style="text-decoration:underline;">Jenis-jenis software antara lain</span></strong> :</p>
<ol>
<li>CP/M-80 (control program for Microprocecor 8080) di pakai pada komputer Appel / Intel 8080</li>
<li>CP/m-86 (control program for Microprocecor 8086) di pakai untuk intel 8086</li>
<li>PC-Dos (Personal Computer Disk Operating System) di buat oleh Microsoft Corppration</li>
<li>MS-DOS (Microsoft Disk Operating System) pengembangan dari PC-DOS</li>
<li>MS-Windows dibuat oleh Microsoft Corporation, mulai dari Windows 3.1, Windows NT, Windows 95, Windows 98, Windows 2000 Profesional, dan Windows XP yang merupakan&nbsp; perbaikan dari&nbsp;&nbsp; versi&nbsp; sebelumnya,&nbsp; komponen&nbsp; strategisnya&nbsp; antara lain :</li>
</ol>
<ul>
<li>Fleksibel dengan hardware yang ada saat ini</li>
<li>Menggunakan konfigurasi hardware otomatis</li>
<li>Prosedur instalasi mudah</li>
<li>Fasilitas jaringan network</li>
<li>Telah memperbaiki bug-bug pada versi sebelumnya.</li>
</ul>
<ol>
<li>Unix adalah sistem operasi yang dikembangkan oleh Dennis M. Ritche dan Ken Thompson, di tulis dalam pemrograman bahasa C.</li>
<li>Linux.</li>
<li>Dll.</li>
</ol>
<p>Ada dua tipe produk perangkat lunak&nbsp; :</p>
<p>1. <em>Produk generik</em></p>
<p>2. <em>Produk pesanan (yang disesuaikan)</em></p>
<p>Pengujian perangkat lunak adalah elemen kritis dari jaminan kualitas perangkat lunak dan merespresentasikan kajian pokok dari spesifikasi, desain dan pengkodean. Meningkatnya visibilitas perangkat lunak sebagai suatu elemen sistem dan “biaya” yang muncul akibat kegagalan perangkat lunak, memotivasi dilakukannya perencanaan yang baik melalui pengujian yang teliti.</p>
<p>Pengujian&nbsp; termasuk dalam&nbsp; teknik verifikasi&nbsp; dan validasi&nbsp; (V &amp; V). Pengujian melibatkan pelatihan perangkat lunak dengan memakai data seperti data riil yang diolah oleh perangkat lunak.</p>
<p>Tujuan akhir dari proses verifikasi dan validasi adalah menanamkan kepercayaan bahwa system perangkat lunak “siap untuk tujuannya”.</p>
<p><em><span style="text-decoration:underline;">Apakah yang dimaksud dengan pengujian perangkat lunak&nbsp; ? </span></em></p>
<ul>
<li>Pengujian adalah proses menjalankan sebuah program dengan maksud menemukan kesalahan-kesalahan (error).</li>
<li>Proses untuk menjalankan sebuah program komputer dan membandingkan tingkah laku yang sesungguhnya dengan yang diharapkan.</li>
<li>Yang dimaksud membandingkan adalah menemukan bentuk penyimpangan-penyimpangan (jika ada). Antara lain membandingkan tingkah laku yang sesungguhnya dengan yang diharapkan.</li>
<li>Layanan pengujian sebagai bentuk suatu rintangan untuk menyediakan produk yang berkualitas dalam mendapatkan pelanggan</li>
</ul>
<p>Pada saat V &amp; V perangkat lunak, kesalahan pada perangkat lunak biasanya ditemukan dan kemudian diubah untuk membetulkan kesalahan tersebut. <em>Proses debug</em> ini seringkali terintegrasi dengan kegiatan verifikasi dan validasi lain.&nbsp; Bagaimanapun, pengujian (atau lebih umum verifikasi dan validasi) dan debug merupakan proses yang berbeda yang tidak harus diintegrasikan :</p>
<ol>
<li><em>Verifikasi dan validasi</em> adalah proses yang meyakinkan&nbsp; adanya kesalahan pada sistem perangkat lunak.</li>
<li><em>Debug</em> merupakan proses yang menemukan dan membetulkan&nbsp; kesalahan tersebut.</li>
</ol>
<p>Tipe pengujian yang dapat digunakan pada berbagai tahap proses perangkat lunak&nbsp; :</p>
<p><strong>1.Pengujian cacat (Defect Testing)</strong></p>
<ul>
<li>Menetapkan keberadaan cacat sistem.</li>
<li>Tujuannya untuk menemukan ketidak konsistenan antara program dan spesifikasinya.</li>
<li>Dirancang untuk mengungkapkan adanya cacat pada sistem dan bukan untuk mensimulasi penggunaan operasionalnya.</li>
<li>Bermanfaat bagi pemrogram dan menunjukkan cacat-cacat yang ada di kode (program).</li>
</ul>
<p><strong>2.Pengujian statistik </strong></p>
<ul>
<li>Menguji kinerja dan keandalan program dan memeriksa bagaimana kerjanya pada kondisi operasional</li>
<li>Dirancang untuk menunjukkan input user yang sebenarnya dan frekuensinya.</li>
<li>Kehandalan sistem dapat dilakukan dengan menghitung kegagalan sistem yang diteliti.</li>
</ul>
<p><strong><span style="text-decoration:underline;">Sasaran Pengujian </span></strong></p>
<p>Glen Myers menyatakan bahwa sasaran dari pengujian perangkat lunak adalah&nbsp; :</p>
<p>1.&nbsp; <em>Pengujian</em> adalah proses menjalankan suatu program dengan maksud menemukan kesalahan.</p>
<p>2.&nbsp; <em>Pengujian yang baik</em> adalah yang memiliki kemungkinan tinggi untuk menemukan kesalahan yang belum pernah ditemukan sebelumnya.</p>
<p>3.&nbsp; <em>Pengujian yang sukses</em> adalah pengujian yang mengungkap semua kesalahan yang belum pernah ditemukan sebelumnya.</p>
<p>Satu hal yang perlu diingat/diperhatikan dalam pengujian terhadap perangkat lunak bahwa :</p>
<p><em>“Pengujian tidak dapat memperlihatkan kerusakan sistem, tetapi hanya dapat memperlihatkan bahwa ada kesalahan perangkat lunak. “</em></p>
<p>Kaner, Falk dan Nguyen mengusulkan atribut-atribut dari</p>
<p>pengujian yang “baik” sebagai berikut&nbsp; :</p>
<p>1.&nbsp; Pengujian yang baik memiliki probabilitas yang tinggi untuk menemukan kesalahan.</p>
<p>2.&nbsp; Pengujian yang baik tidak redundan.</p>
<p>3.&nbsp; Pengujian yang baik seharusnya “jenis terbaik”</p>
<p>4.&nbsp; Pengujian yang baik tidak boleh terlalu sederhana atau terlalu kompleks.</p>
<p>Tidak semua pengujian akan berhasil dengan baik. Masih ada beberapa kekurangan&nbsp; yang&nbsp; terdapat&nbsp;&nbsp; pada&nbsp; pengujian&nbsp;&nbsp; suatu&nbsp; perangkat lunak.</p>
<p>Kekurangan-kekurangan tersebut antara lain :<br>
1.Tidak pernah cukup melakukan banyak ujian yang layak.</p>
<p>2.Pengujian tidak akan menemukan semua kesalahan</p>
<p>3.Pengujian sulit dan menghabiskan banyak waktu</p>
<p>4.Pengujian sebagian besar masih merupakan tugas yang tidak&nbsp; resmi.</p>
<p><strong><span style="text-decoration:underline;">Prinsip-prinsip Pengujian </span></strong></p>
<p>Sebelum menetapkan metode pengujian, seorang ahli pada bidang software harus mengerti betul atau memahami prinsip dasar yang menuntun pengujian perangkat lunak. Prinsip-prinsip pengujian secara umum yang banyak dianut oleh para ahli perangkat lunak, antara lain&nbsp; :</p>
<p></p>
<ul>
<li>Seorang Programmer seharusnya tidak menguji programnya sendiri.</li>
<li>Sebaiknya satu pengujian tidak hanya mengerjakan program yang dianggap benar, tetapi tidak mengerjakan yang dianggap salah.</li>
<li>Tujuan dari pengujian adalah untuk menemukan kesalahan, bukan untuk menunjukkan bahwa program tersebut salah.</li>
<li>Tidak ada sejumlah pengujian yang dapat menjamin bahwa program bebas dari kesalahan.</li>
<li>Bagian-bagian dari program di mana terdapat banyak kesalahan yang telah ditemukan adalah suatu tempat yang baik untuk menemukan kesalahan yang lebih banyak.</li>
<li>Tujuannya adalah bukan untuk mempermalukan programmer.</li>
</ul>
<p></p>
<p>Selain pernyataan diatas, <strong>Roger S. Pressman</strong> mendefinisikan sendiri&nbsp; mengenai prinsip-prinsip pengujian terhadap perangkat lunak&nbsp; :</p>
<ul>
<li>Pengujian harus sesuai dengan persyaratan konsumen.</li>
<li>Para ahli harus betul-betul mengetahui spesifikasi dari&nbsp; produk (software) yang diinginkan konsumen.</li>
<li>Pengujian harus direncanakan lama&nbsp; sebelum pengujian itu di mulai.</li>
<li>Prinsip Pareto berlaku untuk pengujian perangkat lunak.</li>
<li>80 % kesalahan yang ditemukan, hanya dapat ditelusuri&nbsp; sampai 20 % dari semua modul program.</li>
<li>Pengujian harus dimulai dari yang kecil dan berkembang ke pengujian yang besar.</li>
<li>Pengujian berfokus dalam usaha menemukan kesalahan &nbsp;pada modul yang terintegrasi, dan akhirnya pad asistem&nbsp; secara keseluruhan.</li>
<li>Pengujian yang sempurna tidak mungkin.</li>
<li>Agar&nbsp; efektif, pengujian&nbsp; harus dilakukan&nbsp; oleh pihak&nbsp; ketiga yang independent (third party).</li>
<li>Pengujian yang memiliki probabilitas tinggi untuk&nbsp; menemukan kesalahan.</li>
<li>Pembuat sistem bukanlah orang yang paling tepat untuk&nbsp; melakukan semua pengujian bagi perangkat lunak.</li>
</ul>
<p><strong><span style="text-decoration:underline;">Kegagalan dan Kesalahan </span></strong></p>
<p>Kesalahan sistem tidak selalu mengakibatkan eror sistem, karena status salahnya mungkin bersifat sementara dan dapat diperbaiki sebelum terjadi perilaku yang merupakan eror.</p>
<p>Jenis kegagalan dan kesalahan pada sistem antara lain&nbsp; :</p>
<ul>
<li><strong>Kegagalan sistem (<em>system failure</em>)</strong></li>
</ul>
<p>Peristiwa yang terjadi pada suatu waktu ketika sistem tidak memberikan layanan sebagaiman diharapkan oleh user.</p>
<ul>
<li><strong>Eror sistem (<em>system eror</em>)</strong></li>
</ul>
<p>Perilaku eror sistem dimana perilaku, sistem yang tidak sesuai dengan spesifikasinya</p>
<ul>
<li><strong>Kesalahan sistem (<em>system fault</em>)</strong></li>
</ul>
<p>Status sistem yang tidak benar, yaitu status sistem yang tidak diharapkan oleh perancang sistem.</p>
<ul>
<li><strong>Eror atau kesalahan manusia (<em>human error</em>)</strong></li>
</ul>
<p>Perilaku manusia yang mengakibatkan kesalahan sistem.</p>
<p>Bagaimana kesalahan tersebut mempengaruhi kita&nbsp; ?</p>
<p>Telah diketahui bahwa salah satu tujuan dari pengujian terhadap perangkat lunak, adalah untuk menemukan suatu kesalahan. Kesalahan-kesalahan tersebut mempunyai tingkatan-tingkatan yang diukur dengan istilah yang dimengerti oleh manusia. Tingkatan-tingkatan kesalahan tersebut dikategorikan sebagai berikut</p>
<p><strong>A. MILD (<em>ringan</em>)</strong></p>
<p>Gejala dari kesalahan yang mengganggu kita secara estetis</p>
<ul>
<li>Kesalahan pengejaan</li>
<li>Kesalahan penempatan</li>
</ul>
<p><strong>B. MODERATE (<em>sedang</em>)</strong></p>
<ul>
<li>Kesalahan yang berpengaruh pada penampilan system</li>
<li>Informasi yang menyesatkan</li>
</ul>
<p><strong>C. ANNOYING (<em>menjengkelkan</em>)</strong></p>
<ul>
<li>• Kesalahan dari system karena adanya suatu virus.</li>
</ul>
<p>▫&nbsp;&nbsp; Nama yang terpotong</p>
<p>▫&nbsp;&nbsp; Tagihan untuk Rp. 0,00 di cetak / dikirim</p>
<p><strong>D. DISTURBING (<em>mengganggu</em>)</strong></p>
<ul>
<li>Sistem menolak untuk menangani transaksi yang sah</li>
</ul>
<p>▫&nbsp;&nbsp; Kartu kredit yang dilaporkan tidak bisa digunakan</p>
<p><strong>E. SERIOUS (<em>serius</em>)</strong></p>
<ul>
<li>• Perhitungan yang salah</li>
</ul>
<p>▫&nbsp;&nbsp; Hal ini menghilangkan hubungan pada proses transaksi</p>
<p>▫&nbsp;&nbsp; Tidak mencetak setiap pembayaran</p>
<p><strong>F. VERY SERIOUS (<em>sangat serius</em>)</strong></p>
<ul>
<li>Kesalahan yang menyebabkan system melakukan transaksi yang salah</li>
</ul>
<p>▫&nbsp;&nbsp; Sebuah system kredit dapat melakukan kesalahan perhitungan.</p>
<p><strong>G. EXTREME (<em>besar</em>)</strong></p>
<ul>
<li>Masalah yang tidak terbatas pada beberapa transaksi</li>
<li>Sering berubah-ubah atau masalah yang tidak lazim</li>
</ul>
<p><strong>H. INTOLERABLE (<em>kurang tahan</em>)</strong></p>
<ul>
<li>Pertimbangan yang serius diberikan untuk mematikan system.</li>
</ul>
<p><strong>I. CATASTROPHIC (<em>bencana besar</em>)</strong></p>
<ul>
<li>Sistem yang salah</li>
</ul>
<p><strong><br>
</strong></p>
<ul></ul>
<p><strong><span style="text-decoration:underline;">Testability (Kemampuan Test)</span></strong></p>
<p>Testabilitas perangkat lunak adalah seberapa mudah sebuah program komputer dapat diuji. Karena pengujian sangat sulit, maka perlu diketahui apa yang dapat dilakukan untuk membuatnya menjadi mudah. Kadang-kadang pemrogram bersedia melakukan hal-hal yang akan membantu proses pengujian, dan membuat <em>checklist</em> (daftar periksa) mengenai masalah-masalah desain yang mungkin, fitur dan lain sebagainya yang dijadikan sebagai pedoman dalam melakukan pengujian.</p>
<p>Beberapa checklist dibawah ini, akan membantu sebagai pedoman dalam kegiatan pengujian perangkat lunak&nbsp; :</p>
<p>1.&nbsp; <strong>OPERABILITY</strong>. (Mampu menjalankan/operasi.)</p>
<ul>
<li>Semakin baik hal tersebut dijalankan, pengujian akan semakin efesien.</li>
<li>Sistem memiliki sedikit kesalahan.</li>
<li>Tidak ada kesalahan yang menghalangi jalannya pengujian.</li>
<li>Produk berkembang dalam tahapan fungsional (memungkinkan pengembangan dan pengujian secara simultan)</li>
</ul>
<p>2.&nbsp; <strong>OBSERVABILITY</strong>(Kemampuan untuk mengamati/meneliti) “Apa yang dilihat adalah apa yang diuji.”</p>
<ul>
<li>Output yang berbeda dikeluarkan oleh masing-masing input.</li>
<li>Tahap dan variabel sistem dapat dilihat atau diantrikan selama eksekusi.</li>
<li>Sistem dan variabel yang lalu dapat dilihat atau diantrikan (misalnya, logaritma transaksi)</li>
<li>Semua faktor yang mempengaruhi output dapat dilihat.</li>
<li>Output yang tidak benar dapat diidentifikasi dengan mudah.</li>
<li>Kesalahan internal dideteksi secara otomatis melalui mekanisme pengujian itu sendiri.</li>
<li>Kesalahan internal dilaporkan secara otomatis.</li>
<li>Kode sumber dapat diakses.</li>
</ul>
<p>3.&nbsp; <strong>CONTROLLABILITY</strong>(Kemampuan untuk mengawasi)</p>
<p>“ Semakin baik kita dapat mengontrol perangkat lunak, semakin banyak pengujian yang dapat diotomatisasi dan dioptimalkan. “</p>
<ul>
<li>Semua output yang baik, dapat diperoleh melalui beberapa kombinasi input.</li>
<li>Semua kode dapat dijalankan melalui berbagai kombinasi input.</li>
<li>Keadaan dan variabel perangkat lunak dan perangkat keras dapat dikontrol secara langsung oleh penguji.</li>
<li>Format input dan output konsisten dan terstruktur.</li>
<li>Pengujian dapat dispesifikasi, dioptimasi, dan direproduksi dengan baik.</li>
</ul>
<p>4.&nbsp; <strong>DECOMPOSABILITY</strong>(Kemampuan untuk menyelesaikan).</p>
<ul>
<li>Dengan mengontrol ruang lingkup pengujian, kita dapat dengan lebih cepat mengisolasi masalah dan melakukan pengujian kembali secara lebih halus.</li>
<li>Sistem perangkat lunak dibangun dari modul-modul yang independen.</li>
<li>Modul-modul dapat diuji secara independen.</li>
</ul>
<p>5.&nbsp; <strong>SIMPLICITY</strong> (Kemampuan untuk menyederhanakan kerumitan).</p>
<ul>
<li>Semakin sedikit&nbsp; yang diuji, semakin cepat kita dapat mengujinya.</li>
<li>Fungsi yang sederhana (kumpulan fitur adalah kebutuhan minimum untuk memenuhi persyaratan).</li>
<li>Struktur yang sederhana (arsitektur dimodularisasi untuk membatasi penyebaran kesalahan).</li>
<li>Kode yang sederhana (standar pengkodean diadopsi demi kemudahan inspeksi dan pemeliharaan)</li>
</ul>
<p>6.&nbsp; <strong>STABILITY</strong>(Mampu menyeimbangkan ).</p>
<ul>
<li>Semakin sedikit perubahan, semakin sedikit gangguan dalam pengujian.</li>
<li>Perubahan perangkat lunak jarang terjadi.</li>
<li>Perubahan perangkat lunak dapat dikontrol.</li>
<li>Perubahan perangkat lunak memvalidasi pengujian yang sudah ada.</li>
<li>Kegagalan perangkat lunak dapat diperbaiki dengan baik.</li>
</ul>
<p>7.&nbsp; <strong>UNDERSTANDBILITY (</strong>kemampuan untuk memahami/mengerti).</p>
<ul>
<li>Semakin banyak informasi yang kita dapat, semakin mudah pengujian dilakukan.</li>
<li>Rancangan dapat dipahami dengan baik.</li>
<li>Ketergantungan antara komponen internal, eksternal, dan yang dipakai bersama, dipahami dengan baik.</li>
<li>Perubahan rancangan dibicarakan.</li>
<li>Dokumentasi teknik dapat diakses dengan cepat.</li>
<li>Dokumen teknik diorganisasikan dengan baik.</li>
<li>Dokumentasi teknik spesifik dan detail.</li>
<li>Dokumentasi teknik akurat.</li>
</ul>
<p> <strong>MENGAPA PROGRAM MENGALAMI KERUSAKAN ?</strong></p>
<p>&nbsp; Ketika orang mengerjakan tugas-tugas yang kompleks, mereka membuat kesalahan yang tidak dapat dihindari.</p>
<p>&nbsp; Mereka lebih memperbaiki kerusakan-kerusakan selama pengujian.</p>
<p>&nbsp; Mereka harus memperbaiki banyak kesalahan sebelum program akan berjalan semuanya.</p>
<p> <strong>MEMPERBAIKI KERUSAKAN ADALAH SESUATU YANG MAHAL</strong></p>
<p> Dengan waktu sehari, pengujian perangkat lunak secara umum masih mempunyai banyak kerusakan</p>
<p> Komputer akan menjalankan program yang tidak sempurna</p>
<p>&nbsp; ketika menghadapi kerusakan, program tidak akan mengerjakan apa yang seharusnya dikerjakan.</p>
<p>&nbsp; Bahkan mungkin menyebabkan kerugian.</p>
<p> Semakin lama kerusakan tersisa, semakin buruk memperbaikinya</p>
<p>&nbsp; membutuhkan biaya lebih untuk perbaikan</p>
<p>&nbsp; kerusakan yang tersisa akan menjadi penyebab gangguan</p>
<p> <strong>REVIEW (Peninjauan)</strong></p>
<p> Melakukan peninjauan adalah langkah yang terpenting, karena dapat mengembangkan kualitas perangkat lunak.</p>
<p> Lebih awal mengenali dan mengatasi masalah, semakin mudah dan murah untuk memperbaikinya.</p>
<p> <strong>APA YANG PERLU DITINJAU ?</strong></p>
<p> REQUIREMENT &amp; ANALYSIS&nbsp; (pemahaman dan analisa)</p>
<p> DESIGN (rancangan)</p>
<p> CODE (kode)</p>
<p> DOCUMNTATION (dokumentasi)</p>
<p> TEST PLAN &amp; CASES (rencana ujian dan kasus)</p>
<p><strong><span style="text-decoration:underline;">TESTING TECHNIQUE / Teknik Pengujian </span></strong></p>
<p>Pengujian merupakan elemen yang paling kritis dari penilaian perangkat lunak yang telah dikerjakan.</p>
<p>Pembahasan :</p>
<ul>
<li>Dasar-dasar pengujian perangkat lunak</li>
<li>Perancangan permasalahan pengujian yang berfokus pada kumpulan teknik yang digunakan untuk membuat pengujian sesuai dengan permasalahan dan juga disesuaikan dengan&nbsp; tujuan pengujian secara keseluruhan.</li>
</ul>
<p>Pengujian merupakan salah satu dari siklus pengembangan perangkat lunak yang jika ditinjau dari sudut pandang psikologi adalah penghancuran dibandingkan penyusunan.</p>
<p><strong><span style="text-decoration:underline;">Aliran Informasi Pengujian</span></strong><span style="text-decoration:underline;"> </span></p>
<p>Aliran informasi yang terdapat pada saat pengujian dilaksanakan dapat digambarkan sebagai berikut&nbsp; :</p>
<p><strong>Terdapat 2 (dua) tingkatan yang tersedia pada proses pengujian, yaitu&nbsp; :</strong></p>
<ul>
<li>Konfigurasi perangkat lunak yang mencakup spesifikasi keperluan perangkat lunak, spesifikasi perancangan, test case, dan program sumber.</li>
<li>Konfigurasi pengujian yang mencakup rencana dan prosedur uji coba, test case dan hasil yang diharapkan.</li>
</ul>
<p><strong>Desain Test Case</strong></p>
<p>Dengan melihat lagi sasaran pengujian, kita harus mendesain pengujian yang memiliki kemungkinan tertinggi dalam menemukan kesalahan dengan jumlah waktu dan usaha yang minimum.</p>
<p>Terdapat 2 (dua) macam test case&nbsp; :</p>
<ul>
<li>Pengetahuan fungsi yang spesifik dari produk yang telah dirancang untuk diperlihatkan, test dapat dilakukan untuk menilai masing-masing fungsi apakah telah berjalan sebagaimana yang diharapkan.</li>
<li>Pengetahuan tentang cara kerja dari produk, test dapat dilakukan untuk memperlihatkan cara kerja dari produk secara rinci sesuai dengan spesifikasinya.</li>
</ul>
<p>Terdapat dua pendekatan dalam teknik pengujian perangkat lunak&nbsp; :</p>
<ul>
<li><strong>Black Box Testing</strong></li>
</ul>
<p>Dilakukan untuk testing pada interface perangkat lunak. Test&nbsp; case ini bertujuan untuk menunjukkan fungsi perangkat lunak tentang cara beroperasinya, apakah pemasukan data keluaran telah berjalan sebagaimana yang diharapkan dan apakah&nbsp; informasi yang disimpan secara eksternal selalu dijaga kemutakhirannya.</p>
<ul>
<li><strong>White Box Testing</strong></li>
</ul>
<p>Meramalkan cara kerja perangkat lunak secara rinci, karenanya logikal path (jalur logika) yang melewati perangkat lunak diuji dengannmemberikan test case yang menguji serangkaian kondisi&nbsp; dan loop secara spesifik.</p>
<p>Secara sekilas dapat disimpulkan bahwa metoda White Box Testing merupakan petunjuk untuk mendapatkan program yang benar, karena semuanya dilakukan dengan mendefinisikan seluruh jalur logika, mengembangkan test case untuk mengerjakan program, dan mengevaluasi hasilnya, sehingga test case akan mengerjakan logika program secara mendalam.</p>
<p><strong>WHITE BOX TESTING</strong></p>
<p>Pengujian white box adalah metode perancangan test case yang menggunakan struktur kontrol dari perancangan prosedural untuk mendapatkan test case.</p>
<p>Pengujian White Box disebut juga :</p>
<ul>
<li>Glass Box Testing (Pengujian kotak bening)</li>
<li>Code Base Testing&nbsp; (Source kodenya dimunculkan)</li>
<li>Structural Testing (Struktur program ditampilkan)</li>
</ul>
<p>Dengan menggunakan metoda White Box Testing, perekayasa sistem akan dapat melakukan test case yang&nbsp;&nbsp; :</p>
<ol>
<li>Menjamin bahwa seluruh independent path di dalam modul telah dikerjakan paling tidak satu kali.</li>
<li>Mengerjakan seluruh keputusan logika pada sisi <em>true</em> dan <em>false</em></li>
<li>Melaksanakan seluruh loop sesuai dengan batasannya</li>
<li>Mengerjakan seluruh struktur data internal yang menjamin validitas</li>
</ol>
<p><strong><span style="text-decoration:underline;">BASIS-PATH TESTING</span></strong></p>
<p>Pengujian basis path adalah teknik pengujian white box yang diusulkan oleh Tom MacCabe.</p>
<p>Tujuannya memperoleh ukuran kekomplekan logikal dari perancangan prosedural dan menggunakannya sebagai petunjuk untuk menetapkan basis set dari jalur eksekusi.</p>
<p>Objek dari pengujian path adalah untuk meyakinkan bahwa penerapan masalah ujian untuk masing-masing path yang &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; melalui program dilaksanakan setidaknya sekali.</p>
<p>Point permulaan dari pengujian path adalah Folwgraph program yang menunjukkan keputusan program dan aliran kontrol.</p>
<p>Metode pengujian basis path dapat diaplikasikan pada desain prosedural atau kode sumber.</p>
<p><strong>Cyclomatic Complexity</strong></p>
<ul>
<li>Adalah metrik perangkat lunak yang menyediakan ukuran kuantitatif dari kekomplekan logika suatu program.</li>
<li>Nilai yang dihitung untuk cyclomatic complexity menentukan jumlah <em>independent path</em> dalam <em>basis set</em> suatu program.</li>
<li>Memberikan batas atas bagi jumlah pengujian yang harus dilakukan untuk memastikan bahwa seluruh statemen telah dilaksanakan sedikitnya sekali.</li>
<li><em>Independet path</em> adalah jalur yang melintasi atau melalui program dimana sekurang-kurangnya terdapat proses perintah yang baru atau kondisi yang baru.</li>
<li>Dalam flowgraph, independent path harus bergerak sekurang-kurangnya pada satu edge yang belum dilewati sebelum jalur tersebut didefinisikan.</li>
</ul>
<p>Cyclomatic Complexity digunakan untuk mencari jumlah path dalam satu flowgraph. Dapat dicari dengan 3 (tiga) metode, yaitu&nbsp; :</p>
<ul>
<li>Cyclomatic comlpexity <em>V</em> untuk flowgraph dihitung dengan rumus :</li>
</ul>
<p><strong><em>V(G)&nbsp; =&nbsp; E – N + 2</em></strong></p>
<p>dimana&nbsp; <em>E = jumlah Edge</em>, dan <em>N = jumlah Node</em></p>
<ul>
<li>Cyclomatic comlpexity <em>V</em> untuk flowgraph dapat dicari dengan &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rumus :</li>
</ul>
<p><strong><em>V(G) =&nbsp; P + 1</em></strong></p>
<p>dimana <em>P = jumlah predikat node</em></p>
<ul>
<li>Jumlah region dalam flowgraph mempunyai hubungan dengan cyclomatic complexity.</li>
</ul>
<p><strong><em>V(G)&nbsp; =&nbsp; R</em></strong></p>
<p>Nilai cyclomatic complexity memberi batas untuk jumlah jalur independen yang membentuk basis set dan implikasinya, batas atas jumlah pengujian yang harus didesain dan dieksekusi untuk menjamin semua statemen program.</p>
<p><strong>Graph metrik </strong></p>
<ul>
<li>Adalah matrik empat persegi yang mempunyai ukuran (jumlah baris dan kolom) yang sama dengan jumlah node pada flowgraph.</li>
<li>Masing-masing baris dan kolom mempunyai hubungan dengan node yang telah ditentukan.</li>
<li>Pemasukan data matrik berhubungan dengan hubungan (edge) antarnode.</li>
<li>dikembangkan untuk membantu pengujian basis path atau struktur data.</li>
</ul>
<p><strong>LOOP TESTING</strong></p>
<p>Loop merupakan kendala yang sering muncul untuk menerapkan algoritma dengan cepat. Pengujian loop merupakan teknik pengujian white box yang berfokus pada validitas dari loop. Terdapat 4 kelas dari loop,&nbsp; :</p>
<ul>
<li>Simple loop.</li>
<li>Nested loop.</li>
<li>Concanated loop.</li>
<li>Unstructured loop.</li>
</ul>
<p><strong>Simple Loop</strong></p>
<ul>
<li>Diaplikasikan pada bentuk loop yang sederhana, dimana n adalah jumlah maksimum yang diijinkan untuk melalui loop.</li>
<li>lewati loop secara keseluruhan.</li>
<li>hanya satu yang melalui loop</li>
<li>m dapat melalui loop dimana m = n atau m &lt; n</li>
</ul>
<p><strong>Nested loop </strong></p>
<ul>
<li>teruskan sampai semua loop selesai diuji.</li>
</ul>
<p><strong>Concanated Loop</strong></p>
<ul>
<li>Dapat diuji dengan menggunakan pendekatan simple loop bila masing-masing dari loop independent terhadap yang lain.</li>
<li>Bila dua loop dirangkai dan pencacah loop untuk&nbsp; loop 1 digunakan sebagai harga awal untuk loop 2, kemudian loop tersebut menjadi tidak independen, maka pendekatan yang diaplikasikan ke loop tersebut direkomendasikan.</li>
</ul>
<p><strong>Unstructured Loop</strong></p>
<ul>
<li>Apabila memungkinkan, kelas loop ini harus didesain lagi untuk mencerminkan penggunaan konsepsi pemrograman terstruktur.</li>
</ul>
<p><strong>Black Box Testing</strong></p>
<ul>
<li>&nbsp; Metode pengujian black box berfokus pada keperluan fungsional dari perangkat lunak dan domain informasi.</li>
<li>&nbsp; Analis sistem memperoleh kumpulan kondisi dari input yang akan mengerjakan seluruh keperluan fungsional program.</li>
<li>&nbsp; Cenderung diaplikasikan selama tahap akhir pengujian.</li>
<li>&nbsp; Disebut juga pengujian behavioral/pengujian partisi/pengujian interface.</li>
<li>&nbsp; Memperhatikan dari sudut pandang Input data dan Output data.</li>
</ul>
<ul>
<li>Perangkat lunak ditinjau sebagai kotak hitam yang menyalurkan input kepada output berdasarkan rincian dimana perangkat lunak tersebut harus melakukannya.</li>
<li>Periksa kecocokan dari pengujian S/W yang membentuk tingkah laku.</li>
<li>Mencari kesalahan-kesalahan yang dihasilkan oleh kesalahan</li>
<li>Kesalahan perangkat lunak adalah bagian dari perangkat lunak yang tidak menurut pada penyedian definisi itu sendiri dalam dokumen pengembangan.</li>
</ul>
<p>Tujuannya untuk mencari kesalahan-kesalahan pada&nbsp; :</p>
<ul>
<li>Fungsi yang salah atau hilang.</li>
<li>Kesalahan pada interface.</li>
<li>Kesalahan pada struktur data atau akses database.</li>
<li>Kesalahan performansi (kinerja).</li>
<li>Kesalahan initialisasi dan tujuan akhir.</li>
</ul>
<p><span style="text-decoration:underline;">Type dari pengujian black box&nbsp; :</span></p>
<ol>
<li>Equivalence Class Partitioning. (pembagian kelas yang sama)</li>
</ol>
<ul>
<li>Metode pengujian black box yang memecah atau membagi domain input dari suatu program ke dalam kelas-kelas data.</li>
<li>Perancangan test case berdasarkan evaluasi kelas equivalence untuk kondisi input.</li>
<li>Kelas equivalence menggambarkan kumpulan keadaan yang valid dan tidak valid untuk kondisi input.</li>
<li>Kondisi input dapat berupa nilai numerik, range dari nilai, kumpulan nilai yang berhubungan atau kondidi boolean.</li>
</ul>
<p>Kelas equivalence dapat ditentukan sesuai pedoman berikut ini&nbsp; :</p>
<ul>
<li>Bila kondisi input menentukan suatu <em>range</em>, maka kelas equivalence valid dan dua yang invalid ditentukan.</li>
<li>Bila kondisi input membutuhkan suatu <em>harga khusus</em>, maka satu kelas equivalence valid dan dua yang invalid ditentukan.</li>
<li>Bila kondisi input menentukan anggota suatu <em>himpunan</em>, maka satu kelas equivalence valid dan dua yang invalid ditentukan.</li>
<li>Bila kondisi input adalah <em>boolean</em>, maka satu kelas dan satu yang tidak valid ditentukan.</li>
</ul>
<p>Contoh&nbsp; :</p>
<p>Dalam persamaan matematika.</p>
<p>1 juta &lt;= Gaji &lt;= 5 juta</p>
<p>Valid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1 juta samapi 5 juta</p>
<p>Invalid&nbsp;&nbsp;&nbsp;&nbsp; :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; kurang dari 1 juta lebih dari 5 juta</p>
<ol>
<li>Boundary Value Analysis.(analisa penilaian terbatas)</li>
</ol>
<ul>
<li>Untuk permasalahan yang tidak diketahui dengan jelas, akan cenderung menimbulkan kesalahan pada domain output-nya.</li>
<li>Pemilihan test case yang mengerjakan nilai-nilai yang telah ditentukan.</li>
<li>Melengkapi equivalence class partitioning.</li>
</ul>
<p>Petunjuk pemakaian BVA&nbsp; :</p>
<ul>
<li>Jika kondisi input berupa range yang dibatasi oleh nilai a dan b, test case harus dirancang dengan nilai a dan b.</li>
<li>Jika kondisi input ditentukan dengan sejumlah nilai, test case harus dikembangkan dengan mengerjakan sampai batas maksimal dari nilai tersebut.</li>
<li>Sesuai dengan 1 dan 2, untuk kondisi output harus dirancang test case sampai jumlah maksimal.</li>
<li>Untuk struktur data pada program juga harus dirancang sampai batas kemampuan.</li>
</ul>
<ol>
<li>Comparison Testing. (pengujian perbandingan)</li>
</ol>
<ul>
<li>Perangkat keras dan perangkat lunak yang berlebihan memungkinkan untuk digunakan.</li>
<li>Menggunakan team yang terpisah untuk mengembangkan versi-versi yang independent dari perangkat lunak dengan menggunakan spesifikasi yang sama.</li>
<li>Mencoba masing-masing versi dengan data yang sama untuk&nbsp; memastikan bahwa semua versi memberikan output yang identik.</li>
<li>Semua versi dieksekusi secara paralel dengan perbandingan real time hasil untuk memastikan konsistensi.</li>
<li>Output dari masing-masing versi sama implementasi benar.</li>
<li>Output berbeda masing-masing versi dari aplikasi diperiksa untuk menentukan cacat pada suatu versi (perbedaan jelas)</li>
<li>Spesifikasi semua fungsi yang dikembangkan mengandung kesalahan, maka semua versi kemungkinan besar merefleksikan kesalahan.</li>
<li>Masing-masing versi independen identik tetapi tidak benar, maka pengujian kondisi akan gagal mendeteksi kesalahan.</li>
</ul>
<p>TESTING STAGES</p>
<p><strong>Sasaran utama desain test case </strong></p>
<p>untuk mendapatkan serangkaian pengujian yang memiliki kemungkinan tertinggi di dalam pengungkapan kesalahan pada perangkat lunak.</p>
<p><strong>Teknik yang digunakan </strong></p>
<ul>
<li>Pengujian white-box (white–box testing)</li>
<li>Pengujian black-box (black-box testing)</li>
</ul>
<p><strong>Pengujian white-box</strong></p>
<ul>
<li>Berfokus pada struktur kontrol program.</li>
<li>Pengujian dilakukan untuk memastikan bahwa semua statemen pada program telah dieksekusi paling tidak satu kali selama pengujian &nbsp;&nbsp; dan semua kondisi telah diuji.</li>
<li>Pengujian basis path, teknik pengujian white-box, menggunakan grafik program (matrik grafik) untuk melakukan serangkaian pengujian yang independen secara linear yang memastikan cakupan.</li>
<li>Pengujian aliran data dan kondisi lebih lanjut menggunakan logika program, dan pengujian loop menyempurnakan teknik white box yang lain dengan memberikan sebuah prosedur untuk menguji loop dari tingkat kompleksitas yang bervariasi.</li>
<li>Implikasinya secara khusus diaplikasikan ke dalam komponen program yang kecil (modul atau kelompok kecil dari modul).</li>
</ul>
<p><strong>Pengujian black-box</strong></p>
<ul>
<li>Didesain untuk mengungkap kesalahan pada persyaratan fungsional &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tanpa mengabaikan kerja internal dari suatu program.</li>
<li>Berfokus pada domain informasi dari perangkat lunak.</li>
<li>Melakukan teste case dengan&nbsp; mempartisi domain input dan output dari suatu program dengan cara yang memberikan cakupan pengujian yang mendalam.</li>
<li>Partisi ekivalensi (Equivalence Class Partitioning) membagi domain  input kedalam kelas data yang mungkin untuk melakukan fungsi perangkat lunak tertentu.</li>
<li>Analisis nilai terbatas (Boundary Value Analysis) memeriksa kemampuan program untuk menangani data pada patas yang dapat diterima.</li>
<li>Pengujian perbandingan (Comparison Testing) mengembangkan perangkat lunak ke dalam versi-versi yang independen dari suatu aplikasi dengan menggunakan spesifikasi yang sama. Setiap versi  diuji dengan data uji yang sama untuk memastikan bahwa &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; semua versi memberikan output yagn identik. Disebut juga &nbsp;&nbsp;&nbsp; pengujian back to &nbsp; back.</li>
</ul>
<p>Pengembang perangkat lunak yang berpengalaman sering mengatakan, “Pengujian tidak akan pernah berakhir. Pengujian hanya berpindah dari Penguji ke pelanggan. Setiap pelanggan menggunakan program tersebut, berarti suatu pengujian dilakukan.”</p>
<p>Dengan mengaplikasikan desain test case, perekayasa perangkat lunak&nbsp; dapat menapai pengujian yang lebih lengkap sehingga dapat mengungkap dan melakukan koreksi sebelum “pengujian pelanggan” dimulai.</p>
<p>TESTING STAGES (tingkatan pengujian</p>
<p>Validasi perangkat lunak (V &amp; V) ditujukan untuk menunjukkan bahwa sistem sesuai dengan spesifikasinya dan bahwa sistem memenuhi harapan pelanggan yang membelinya. Validasi melibatkan proses pemeriksaan, seperti inspeksi dan peninjauan, pada setiap proses perangkat lunak dari definisi persyaratan user sampai pengembangan program.</p>
<p><em>Validasi perangkat lunak adalah proses pemeriksaan untuk menjamin agar sistem telah sesuai dengan spesifikasinya dan memenuhi kebutuhan sesungguhnya dari user sistem.</em></p>
<p>Namun demikian, mayoritas biaya validasi disediakan setelah implementasi sistem operasional diuji.</p>
<ul>
<li>Untuk program-program kecil, sistem seharusnya tidak diuji sebagai sistem tunggal. Sistem besar dibangun dari subsistem yang dibangun dari model yang terbuat dari prosedur dan fungsi.</li>
<li>Proses demikian dengan demikian harus dilakukan bertahap, dimana pengujian dilakukan secara inkremental bersama dengan implementasi sistem.</li>
<li>Proses pengujian terdiri dari 3 (tiga) tahap dimana komponen-komponen sistem diuji, sistem yang terintegrasi diuji, dan akhirnya sistem diuji dengan data pelanggan.</li>
<li>Idealnya, kesalahan komponen ditemukan dini pada proses dan masalah interface ketika sistem diintegrasi.</li>
<li>Namun demikian, dengan ditemukannya kesalahan, program harus didebug.</li>
<li>Hal ini menuntut tahap proses pengujian ulang.</li>
<li>Error pada komponen program, bisa muncul pada saat pengujian itegrasi.</li>
<li>Proses dengan demikian bersifat iteratif, dengan informasi diumpan balik dari bagian akhir ke bagian awal proses.</li>
</ul>
<p>Tahap-tahap pada proses pengujian&nbsp; :</p>
<p><strong>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Unit Testing (<em>pengujian unit</em>).</strong></p>
<ul>
<li>Komponen individual diuji untuk menjamin operasi yang &nbsp;&nbsp;&nbsp; benar.</li>
<li>Setiap komponen diuji secara independen, tanpa komponen sistem &nbsp; yang lain.</li>
</ul>
<p><strong>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Modul Testing (<em>pengujian modul</em>).</strong></p>
<ul>
<li>Modul merupakan sekumpulan komponen yang berhubungan seperti kelas objek, atau sekumpulan prosedur dan fungsi. Sebuah modul merangkum komponen-komponen yang berhubungan, sehingga dapat diuji tanpa modul sistem yang lain.</li>
</ul>
<p><strong>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sub-system Testing (<em>pengujian subsistem</em>).</strong></p>
<p>♠&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Melibatkan pengujian sekumpulan modul yang telah diintegrasikan menjadi subsistem.</p>
<p>♠&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Masalah yang sering muncul pada sistem perangkat lunak besar adalah ketidaksesuaian interface.</p>
<p>♠&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Proses pengujian subsistem dengan demikian harus terkonsentrasi pada deteksi kesalahan interface modul dengan menjalankan interface ini berkali-kali.</p>
<p><strong>4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; System Testing (<em>pengujian sistem</em>).</strong></p>
<ul>
<li>Subsistem diintegrasikan untuk membentuk sistem. Proses ini berkenaan dengan penemuan kesalahan yang diakibatkan dari interaksi yang tidak diharapkan antara subsistem dan masalah interface subsistem.</li>
<li>Sistem pengujian secara keseluruhan dimana pengujian timbul karena sifat-sifat yang baru.</li>
<li>Pengujian atas penggabungan sistem perangkat lunak.</li>
</ul>
<p><strong>5.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Acceptance Testing (<em>pengujian penerimaan</em>).</strong></p>
<p>v&nbsp; Merupakan tahap akhir proses pengujian sebelum sistem diterima untuk penggunaan operasional.</p>
<p>v&nbsp; Sistem diuji dengan data yang dipasok oleh pelanggan dan bukan data uji simulasi.</p>
<p>v&nbsp; Bisa menunjukkan kesalahan dan penghapusan definisi persyaratan&nbsp; sistem karena data riil menjalankan sistem dengan cara yang berbeda dari data uji.</p>
<p>v&nbsp; Dapat mengungkap masalah persyaratan dimana fasilitas sistem tidak memenuhi keperluan user atau kinerja sistem tidak dapat diterima.</p>
<ul>
<li>Pengujian unit dan pengujian modul biasanya merupakan tanggung  jawab programmer yang mengembangkan komponen tersebut. Programer membuat data uji sendiri dan secara inkremental menguji kode pada saat dikembangkan. Pengujian ini sangat ekonomis karena programmer adalah orang yang paling mengetahui komponen tersebut dan merupakan orang terbaik untuk membuat data uji.</li>
<li>Tahap berikutnya mencakup integrasi dari sejumlah programmer dan harus direncanakan sebelumnya. Suatu tim penguji independent harus bekerja dari rencana uji pra-formulasi yang dikembangkan dari spesifikasi dan rancangan sistem.</li>
<li>Pengujian penerimaan kadang-kadang disebut <em>pengujian alpha</em>. Sistem yang diperlihatkan dikembangkan untuk satu klien. Proses pengujian alpha berlanjut sampai pengembang sistem dan pelanggan setuju bahwa sistem yang diserahkan merupakan implementasi yang dapat diterima dari persyaratan sistem.</li>
</ul>
<p>STRATEGI PENGUJIAN PERANGKAT LUNAK</p>
<ul>
<li>Strategi untuk pengujian perangkat lunak mengintegrasikan metode desain test case perangkat lunak ke dalam sederetan langkah yang direncanakan dengan baik, hasilnya adalah konstruksi perangkat lunak yang berhasil.</li>
<li>Strategi pengujian perangkat lunak memberikan sebuah peta jalan bagi pengambang perangkat lunak, organisasi jaminan kualitas, dan pelanggan.</li>
<li>Peta jalan menggambarkan langkah-langkah yang akan dilakukan sebagai bagian dari pengujian, kapan langkah-langkah itu direncanakan dan kemudian dijalankan, serta berapa banyak usaha, waktu, dan sumber daya yang dibutuhkan.</li>
<li>Strategi pengujian menggabungkan perencanan pengujian, desain test case, dan kumpulan data resultan (hasil) serta evaluasi.</li>
</ul>
<p><strong><em>Kesimpulan&nbsp; :</em></strong></p>
<ul>
<li><em>Strategi pengujian perangkat lunak memudahkan para perancang untuk menentukan keberhasilan dari sistem yang telah dikerjakan.</em></li>
<li><em>Hal yang harus diperhatikan adalah langkah-langkah perencanaan dan pelaksanaan harus direncanakan dengan baik dan berapa lama waktu, upaya dan sumber daya yang diperlukan.</em></li>
</ul>
<p><strong>Pendekatan Strategis ke pengujian perangkat lunak </strong></p>
<p>Pengujian adalah serangkaian aktivitas yang dapat direncanakan sebelumnya dan dilakukan secara sistematis. Karena ituah harus ditentukan suatu template untuk desain perangkat lunak – serangkaian langkah yang di dalamnya kita dapat menempatkan metode desain test case yang spesifik – untuk proses rekayasa perangkat lunak.</p>
<p>Banyak strategi pengujian yang dapat digunakan, tetapi secara umum mempunyai karakteristik sebagai berikut&nbsp; :</p>
<ul>
<li>Pengujian      dimulai pada tingkat modul yang palin bawah, dilanjutkan dengan modul di      atasnya kemudian hasilnya dipadukan.</li>
<li>Teknik      pengujian yang berbeda mungkin akan menghasilkan sedikit perbedaan dalam      hal waktu.</li>
<li>Pengujian      dilakukan oleh pengembang perangkat lunak &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dan      (untuk proyek yang besar) suatu kelompok pengujian yang independen.</li>
<li>Pengujian      dan debugging merupakan aktivitas yang berbeda, tetapi debugging termasuk      dalam strategi pengujian.</li>
</ul>
<p>Pengujian perangkat lunak adalah suatu elemen dari topik yang sangat luas dimana dapat disebut sebagai <em>verifikasi dan validasi (V &amp; V).</em></p>
<p><em>Verifikasi</em> adalah kumpulan aktivitas yang menjamin bahwa perangkat lunak benar-benar sesuai dengan fungsinya.</p>
<p><em>Validasi</em> adalah&nbsp; serangkain aktivitas yang berbeda yang memastikan bahwa perangkat lunak yang dibangun dapat sesuai dengan kepeluan pelanggan.<em> </em></p>
<p><strong>Strategi pengujian perangkat lunak </strong></p>
<p>v&nbsp; Proses rekayasa perangkat lunak dapat juga dipandang sebagai sebuah bentuk spiral.</p>
<p>v&nbsp; Pada awalnya, rekayasa sistem menentukan peran perangkat lunak dan membawa kepada analis persyaratan di mana domain informasi, fungsi, tingkah laku dan kinerja validasi bagi perangkat lunak di bangun.</p>
<p>v&nbsp; Dengan bergerak dalam sepanjang spiral, kita akan sampai ke desain dan akhirnya ke pengkodean.</p>
<p><em> </em></p>
<ul>
<li><em>Unit testing</em> dimulai pada pusaran spiral dan terpusat pada masing-masing satuan perangkat lunak pada saat diimplementasikan di dalam kode sumber.</li>
<li>Pengujian berjalan dengan bergerak keluar sepanjang spiral ke <em>integration testing</em> di mana fokusnya adalah desain dan konstruksi arsitektur perangkat lunak.</li>
<li>Dengan mengambil urutan keluar lainnya di dalam spiral, akan sampai ke <em>validation testing</em> di mana persyaratan yang dibangun sebagai bagian dari analisis persyaratan perangkat lunak di validasi terhadap perangkat lunak yang telah dikonstruksi.</li>
<li>Akhirnya sampai pada <em>system tesing</em> di mana perangkat lunak dan elemen sistem yang lain diuji secara keseluruhan.</li>
</ul>
<p>Dengan mempertimbangkan proses dari titik pandang prosedural, pengujian di dalam konteks rekayasa perangkat lunak secara aktual merupakan 4 (empat) langkah yang diimplementasi secara berurutan.</p>
<ol>
<li>Pada awalnya, pengujian berfokus pada setiap modul secara individual, dengan memastikan bahwa modul berfungsi secara tepat sebagai suatu unit, karena itu dinamakan <em>unit testing</em>. Menggunakan metoda pengujian white-box. Selanjutnya modul diintegrasikan untuk membentuk paket perangkat lunak yang lengkap.</li>
<li><em>Integration testing</em> menekankan pada masalah-masalah yang berhubungan dengan masalah-masalah verifikasi dan konstruksi program. Mengunakan teknik pengujian black-box.</li>
<li><em>Validation testing</em> memberikan jaminan akhir di mana perangkat lunak harus memenuhi semua persyaratan fungsional, tingkah laku dan kinerja. Teknik pengujian black-box digunakan secara eksklusif selama validasi. Perangkat lunak, sekali divalidasi, harus dikombinasikan dengan elemen sistem yang lain (hardware, manusia, database).</li>
<li><em>Pengujian sistem</em> membuktikan bahwa semua elemen sistem saling bertautan dengan tepat dan keseluruhan fungsi/kinerja sistem dapat dicapai.</li>
</ol>
<p><strong>UNIT TESTING (pengujian unit)</strong></p>
<p>Pengujian berfokus pada usaha verifikasi pada unit terkecil dari desain perangkat lunak, yakni modul. Dengan menggunakan deskripsi desain terinci sebagai panduan, jalur kontrol yang penting diuji untuk mengungkap kesalahan di dalam batas dari modul tersebut. Kompleksitas dari pengujian dan kesalahan ditentukan berdasarkan scope modul. Pengujian unit selalu berorientasi ke white-box testing dan dapat dikerjakan dengan paralel atau berurutan dengan modul-modul yang lainnya.</p>
<p><strong>Unit Testing</strong></p>
<ul>
<li>Unit individu diuji secara terpisah.</li>
<li>Unit mungkin menjadi fungsi-fungsi sendiri, prosedur atau program.</li>
<li>Dikerjakan secara meningkat, biasanya oleh programmer sendiri yang memberikan kodenya.</li>
<li>Kebanyakan white-box testing cocok untuk tingkatan ini.</li>
<li>Susunan data ujian lokal, kondisi boundary, path independent dan path penanganan kesalahan.</li>
<li>Tak resmi, rencana ujian tidak resmi, jelas dan tertulis.</li>
<li>Interface diuji untuk menjamin informasi yang mengalir masuk dan keluar dari unit program telah tepat atau sesuai dengan yang diharapkan.</li>
<li>Struktur data lokal dikerjakan untuk menjamin penyimpanan data selalu muthakir.</li>
<li>Kondisi batasan-batasan adalah pengujian untuk menjamin modul-modul dioperasikan sesuai dengan batasannya.</li>
<li>Independent path untuk menjamin seluruh perintah dalam modul telah bekerja dengan baik.</li>
<li>Penanganan kesalahan kesalahan merupakan langkah terakhir dalam tahap ini.</li>
</ul>
<p><strong><span style="text-decoration:underline;"> </span></strong></p>
<p><strong><span style="text-decoration:underline;">Prosedur pengujian unit.</span></strong></p>
<ul>
<li>Pengujian unit pada umumnya merupakan perkembangan dari langkah pengkodean.</li>
<li>Setelah program sumber dikembangkan, ditinjau kembali dan diverifikasi untuk sintaknya, maka perancangan test case di mulai.</li>
<li>Peninjauan kembali perancangan informasi akan menyediakan petunjuk untuk menentukan test case.</li>
<li>Karena modul bukan program yang berdiri sendiri, maka driver (pengendali) dan atau stub perangkat lunak harus dikembangkan untuk tiap-tiap pengujian unit.</li>
</ul>
<p><strong> </strong></p>
<p><strong>MODUL TESTING (pengujian modul)</strong></p>
<ul>
<li>Pengujian interaksi dari semua komponen yang berhubungan terhadap modul.</li>
<li>Pengujian modul yang indpendent.</li>
<li>Modul secara individu diuji secara terpisah.</li>
<li>Modul berupa kumpulan fungsi, prosedure atau program-program.</li>
<li>Tidak secara increment, biasanya dilakukan oleh seorang programmer yang membuat program tersebut.</li>
<li>Menggunakan stub dan driver.</li>
<li>Pengujian whit-box cocok untuk tingkatan ini.</li>
<li>Pengujian struktur data lokal, kondisi batasan, jalur independen, jalur penanganan kesalahan.</li>
<li>Formal : rencana pengujian dijelaskan dan tertulis.</li>
<li>Modul bukanlah program yang berdiri sendiri, perangkat lunak driver dan atau stub harus dikembangkan bagi masing-masing pengujian unit.</li>
<li>Pada sebagian besar aplikasi, driver tidak lebih dari sebuah “program utama”, yang menerima data test case.</li>
<li>Data sampai ke modul untuk diuji, dan kemudian mencetak hasil yang relevan.</li>
<li>Stub berfungsi untuk menggantikan modul yang merupakan subordinat dari modul yang akan diuji.</li>
<li>Stub menggunakan interface modul subordinat untuk melakukan manipulasi data minimal, mencetak , entri dan kembali.</li>
</ul>
<p><strong>INTEGRATION TESTING (pengujian integrasi)</strong></p>
<p>♪&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pengujian integrasi adalah teknik yang sistematis untuk mengkonstruksi susunan program sambil melakukan pengujian&nbsp; untuk memeriksa kesalahan yang nantinya digabungkan dengan interface.</p>
<p>♪&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Sasarannya adalah untuk mengambil modul yang dikenai pengujian unit dan membangun struktur program yang telah ditentukan oleh desain.</p>
<p>♪&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Kesulitannya adalah lokalisasi error yang sulit ditemukan pada saat proses.</p>
<p>♪&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Terdapat interaksi yang rumit antara komponen sistem dan ketika ditemukan output yang menyimpang, mungkin sulit untuk menemukan sumber error tersebut.</p>
<p><strong>Integrasi non-inkremental </strong></p>
<p>Program diuji sebagai satu kesatuan. Serangkaian kesalahan akan terjadi. Koreksi sulit dilakukan karena isolasi penyebab diperumit oleh luasnya program keseluruhan. Sekali kesalahan tersebut dibetulkan, maka akan muncul lagi yang baru dan proses itu terus berlanjut dalam loop yang kelihatannya tidak akan pernah berhenti.</p>
<p><strong>Integrasi inkremental </strong></p>
<p>Program dibangun dan diuji di dalam segmen-segmen kecil, sehingga kesalahan lebih mudah diisolasi dan dibetulkan, interface lebih mungkin untuk diuji secara lengkap, dan pendekatan pengujian yang sistematis dapat diaplikasikan.</p>
<p><strong><span style="text-decoration:underline;">Top-down Integrasi</span></strong></p>
<ul>
<li>adalah pendekatan inkremental terhadap struktur program.</li>
<li>Modul diintegrasikan dengan menggerakkan ke bawah melalui hirarki kontrol, dimulai dengan modul kontrol utama (program utama).</li>
<li>Memverifikasi kontrol utama dan keputusan pada saat awal proses pengujian.</li>
<li>Pada struktur program yang dibuat dengan baik, keputusan akan dikerjakan pada tingkat atas hirarki.</li>
<li>Stub mengganti modul tingkat rendah pada awal pengujian top-down, sehingga tidak ada data yang penting yang dapat mengalir ke atas di dalam struktur program.</li>
</ul>
<p>Proses integrasi dilakukan dalam 5 (lima) langkah&nbsp; :</p>
<ol>
<li>Modul kontrol utama digunakan sebagai test driver, dan stub ditambahkan pada semua modul yang secara langsung subordinat terhadap modul kontrol utama.</li>
<li>Stub subordinat diganti pada suatu saat dengan modul aktual.</li>
<li>Pengujian dilakukan pada saat masing-masing modul diintegrasi.</li>
<li>Pada pelengkapan masing-masing rangkaian pengujian, stub yang lain diganti dengan modul real.</li>
<li>Pengujian regresi dapat dilakukan untuk memastikan bahwa kesalahan baru belum dimunculkan.</li>
</ol>
<p><strong><span style="text-decoration:underline;">Bottom-up Integrasi</span></strong></p>
<ul>
<li>Dapat dinyatakan dengan penyusunan yang dimulai dan diuji dengan atomic modul (modul tingkat paling bawah pada struktur program).</li>
<li>Modul diintegrasikan dari bawah ke atas sehingga pemrosesan yang diperlukan untuk modul subordinat yang selalu diberikan akan selalu tersedia dan kebutuhan akan stub dapat dieliminasi.</li>
</ul>
<p>Strategi bottom-up integration dapat diterapkan dengan urutan langkah-langkah sebagai berikut&nbsp; :</p>
<ol>
<li>Modul tingkat bawah digabungkan ke dalam <em>cluster</em> (sering disebut <em>build</em>) yang malakukan subfungsi perangkat lunak spesifik.</li>
<li>Driver (program kontrol untuk pengujian) ditulis untuk mengkoordinasi input dan output test case.</li>
<li>Cluster diuji.</li>
<li>Driver diganti dan cluster digabungkan dengan  menggerakkannya ke atas di dalam struktur program.</li>
</ol>
<p><strong><span style="text-decoration:underline;">Regression Testing (<em>pengujian regresi</em>)</span></strong></p>
<ul>
<li>adalah aktivitas yang membantu memastikan bahwa perubahan (karena pengujian atau alasan lain) tidak menimbulkan tingkah laku yang tidak diharapkan atau kesalahan tambahan.</li>
<li>Merupakan eksekusi ulang dari beberapa subset yang telah dilakukan untuk memastikan bahwa perubahan tidak menimbulkan efek samping yang tidak diharapkan.</li>
<li>Pengujian yang berhasil akan menghasilkan kesalahan, dan setiap kesalahan harus dikoreksi.</li>
<li>Setiap kali perangkat lunak dikoreksi, maka banyak aspek konfigurasi perangkat lunak (program, dokumentasi atau data yang mendukung) akan diubah.</li>
</ul>
<p>Pengujian regresi (subset dari pengujian yang akan dieksekusi) berisi tiga kelas test case yang berbeda, yaitu&nbsp; :</p>
<ul>
<li>Sampel respresentatif dari pengujian yang akan &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; menggunakan semua fungsi perangkat lunak.</li>
<li>Pengujian tambahan yang berfokus pada fungsi-fungsi  perangkat lunak yang mungkin dipengaruhi oleh perubahan tersebut.</li>
<li>Pengujian yang berfokus pada komponen perangkat lunak yang telah diubah.</li>
<li>Pemilihan strategi integrasi, tergantung pada karakteristik perangkat lunak dan kadang-kadang juga pada jadwal proyek.</li>
<li>Secara umum, pendekatan yang digabungkan (<em>sandwitch testing</em>), yang menggunakan strategi top-down untuk tingkat yang lebih tinggi dari struktur program, dipasangkan dengan strategi bottom-up untuk tingkat subordinat.</li>
<li>Pada saat pengujian integrasi dilakukan, penguji&nbsp; harus mengidentifikasi modul kritis. Modul kritis memiliki karakteristik sebagai berikut :</li>
</ul>
<ol>
<li>menekankan beberapa persyaratan perangkat lunak.</li>
<li>memiliki tingkat kontrol yang tinggi.</li>
<li>Kompleks (cyclomatic complexity dapat digunakan sebagai indikator).</li>
<li>memiliki persyaratan kinerja yang terbatas.</li>
</ol>
<p><em>Scope of Testing</em> merangkum fungsi yang spesifik, kinerja dan karakteristik desain internal yang akan diuji. Pengujian dibatasi ; kriteria perlengkapan dari masing-masing fase pengujian digambarkan; dan batasan jadwal didokumentasikan.</p>
<p><em>Test Plan</em> menggambarkan seluruh strategi integrasi. Pengujian dibagi ke dalam <em>phases</em> dan <em>builds</em> yang menekankan fungsional spesifik dan karakteristik tingkah laku dari perangkat lunak tersebut. Misalnya pengujian integrasi untuk sebuah sistem komputer yang berorientasi pada grafik dapat dibagi ke dalam fase-fase pengujian sebagai berikut&nbsp; :</p>
<ul>
<li>Interaksi pemakai      (seleksi perintah, representasi tampilan, pemrosesan dan respresentasi      kesalahan).</li>
<li>Manipulasi dan analisis      data (pembuatan simbol, penentuan dimensi, rotasi, komputasi sifat fisis)</li>
<li>Pemrosesan dan      pemunculan tampilan (tampilan dua dimensi, tampilan tiga dimensi, grafik      dan bagan)</li>
<li>Manajemen database      (akses, update, integritas, kinerja)</li>
</ul>
<p>Kriteria dan pengujian yang sesuai diaplikasikan untuk semua fase pengujian&nbsp; :</p>
<ul>
<li><em>Integritas interface</em>. Antar muka internal dan eksternal diuji pada saat masing-masing modul (kluster) ditambahkan ke dalam struktur.</li>
<li><em>Validitas fungsional</em>. Pengujian yang didesain untuk mengungkap kesalahan fungsional yang dilakukan.</li>
<li><em>Isi informasi. </em>Pengujian yang didesain untuk mengungkap kesalahan yang berhubungan dengan struktur data global atau lokal yang dilakukuan.</li>
<li><em>Kinerja</em>. Pengujian yang didesain untuk memeriksa batasan kinerja yang dibangun selama desain perangkat lunak dilakukan.</li>
</ul>
<p><strong>VALIDATION TESTING (pengujian validasi)</strong></p>
<ul>
<li>Dilakukan setelah      integration testing dilakukan serta kesalahan-kesalahan yang ditemukan      telah diperbaiki.</li>
<li>Validasi berhasil jika      fungsi-fungsi yang ada pada perangkat lunak telah sesuai dengan yang      diharapkan oleh pemakai.</li>
<li>Merupakan kumpulan      pengujian black-box yang memperlihatkan atau menunjukkan sesuai dengan      yang diperlukan.</li>
<li>Garis besar rencana      pengujian dikerjakan dan prosedur pengujian didefinisikan dengan test case      yang spesifik untuk menunjukkan sesuai dengan yang diperlukan.</li>
<li>Rencana dan prosedur      dirancang untuk menjamin seluruh keperluan fungsional telah terpenuhi,      seluruh performansi dapat dicapai, dokumentasi dilakukan dengan benar.</li>
</ul>
<p>Setelah pengujian dikerjakan, ada satu kemungkinan dari dua kondisi yang ada, yaitu&nbsp; :</p>
<ol>
<li>Karakteristik performansi      fungsi sesuai dengan spesifikasi dan dapat diterima.</li>
<li>Penyimpangan dari      spesifikasi ditemukan dan daftar penyimpangan dibuat.</li>
</ol>
<p><strong>Kajian Konfigurasi </strong></p>
<ul>
<li>Merupakan elemen penting dari proses validasi.</li>
<li>Tujuannya untuk memastikan apakah semua elemen konfigurasi perangkat lunak telah dikembangkan dengan tepat, dikatalog, dan memiliki detail yang perlu untuk mendukung fase pemeliharaan dari siklus hidup perangkat lunak.</li>
<li>Sering disebut <em>audit.</em></li>
</ul>
<p><strong><span style="text-decoration:underline;"> </span></strong></p>
<p><strong><span style="text-decoration:underline;">ALPHA &amp; BETA TESTING</span></strong></p>
<ul>
<li>Sangat tidak mungkin bagi pengembang perangkat lunak untuk meramalkan bagaimana pelanggan akan benar-benar menggunakan sebuah program.</li>
<li>Instruksi yang digunakan dapat disalah-interprestasikan, kombinasi data yang aneh dapat dipakai secara reguler, dan output yang kelihatannya sudah jelas bagi penguji tidak dapat dimengerti oleh pemakai di lapangan.</li>
<li>Bila perangkat lunak biasa dibangun bagi satu pelanggan, maka dapat acceptance test dapat dilakukan untuk memungkinkan pelanggan memvalidasi semua persyaratan.</li>
<li>Acceptance test dilakukan karena memungkinkan pelanggan untuk menemukan kesalahan yang lebih terinci dan membiasakan pelanggan memahami perangkat lunak yang telah dibuat.</li>
<li>Jika perangkat lunak dikembangkan atau dibuat untuk dipakai oleh banyak pelanggan, maka tidak praktis untuk melakukan pengujian satu per satu terhadap perangkat lunak tersebut.</li>
<li>Maka digunakan alpha dan beta testing.</li>
<li><em>Alpha testing</em> adalah tahap pengembangan, dimana perangkat lunak atau perangkat keras yang telah dibuat dikirim ke kelompok pemakai atau pembeli yang potensial kemudian mereka akan menggunakan produk ini untuk melaporkan jika produk itu gagal ?</li>
<li>Pengujian aplha dilakukan pada sebuah lingkungan yang terkontrol.</li>
<li>Pengujian beta dilakukan oleh pelanggan yang merupakan pemakai akhir perangkat lunak.</li>
<li><em>Pengujian beta</em> merupakan sebuah aplikasi “live” dari perangkat lunak dalam suatu lingkungan yang tidak dapat dikontrol oleh pengembang.</li>
<li>Pelanggan merekam semua masalah yang ditemui selama pengujian beta dan melaporkannya kepada pengembang.</li>
<li>Pengembang melakukan modifikasi kemudian mempersiapkan pelepasan produk ke seluruh pelanggan.</li>
</ul>
<p><strong><span style="text-decoration:underline;">SYSTEM&nbsp; TESTING</span></strong></p>
<ul>
<li>Perangkat lunak merupakan salah satu elemen dari sistem yang berbasis komputer yang sangat besar.</li>
<li>Perangkat lunak diintegrasi dengan elemen sistem lainnya (hardware, informasi) dan serangkaian integrasi sistem dan validasi test dilakukan.</li>
<li>Jika pengujian gagal atau diluar scope dari pengembangan sistem dan tidak hanya dikerjakan oleh programmer, maka langkah yang diambil selama perancangan dan pengujian dapat diperbaiki</li>
<li>Peran analis sistem antara lain&nbsp; :
<ul>
<li>Menangani kesalahan yang muncul dari elemen-elemen perangkat lunak</li>
<li>Mengerjakan serangkaian pengujian</li>
<li>Mencatat hasil pengujian.</li>
<li>Berpartisipasi dalam perencanaan dan merangcang pengujian sistem untuk menjamin kualitas perangkat lunak.</li>
<li>System testing adalah sederetan pengujian yang berbeda-beda dengan tujuan utama mengerjakan keseluruhan elemen dalam sistem yang telah dikembangkan.</li>
</ul>
</li>
</ul>
<p><strong><span style="text-decoration:underline;">Stress Testing (<em>pengujian stres</em>)</span></strong></p>
<ul>
<li>Didesain untuk menghadapi situasi yang tidak normal pada saat program mengalami pengujian.</li>
<li>Dilakukan oleh sistem untuk kondisi-kondisi seperti volume data yang normal (melebihi atau kurang dari batasan), frekuensi dll.</li>
<li>Intinya penguji berusaha untuk merusak program.</li>
</ul>
<p><strong><span style="text-decoration:underline;">Recovery Testing (<em>pengujian perbaikan</em>)</span></strong></p>
<ul>
<li>Adalah pengujian sistem yang memaksa perangkat lunak untuk mengalami kegagalan dalam berbagai cara dan melakukan verifikasi sesuai dengan performansi yang tepat.</li>
<li>Banyak sistem yang berbasis komputer harus melindungi dari kesalahan dan melanjutkan prosesnya dalam waktu yang telah ditentukan.</li>
<li>Sistem harus toleran terhadap kesalahan. Kesalahan pemrosesan tidak boleh menyebabkan keseluruhan fungsi sistem berhenti.</li>
</ul>
<p><strong><span style="text-decoration:underline;">Security Testing (<em>pengujian keamanan</em>)</span></strong></p>
<ul>
<li>Adalah pengujian yang akan melakukan verifikasi dari mekanisme perlindungan yang akan dibuat oleh sistem, melindungi dari hal-hal yang mungkin terjadi.</li>
<li>Penguji memerankan individu yang akan menembus sistem.</li>
<li>Pengujian untuk mencoba menembus tingkat keamanan sebuah perangkat lunak.</li>
</ul>
<ul>
<li><em>Strategi      Sandwich Compromise,</em> menguji perangkat lunak dengan melakukan      pengujian mulai dari entry-point tertentu kemudian bergerak keatas ataupun      kebawah.</li>
<li><em>Volume      Testing,</em> menguji perangkat lunak dengan memberi data yang berlebihan.</li>
<li><em>Configuration      Testing,</em> menguji berbagai variasi perangkat lunak diberbagai      lingkungan perangkat lunak.</li>
<li><em>Compatibility      Testing</em>, menguji kesesuaian sebuah perangkat lunak dengan sistem yang      sedang dimanfaatkan.</li>
<li><em>Timing      sistem</em>, melakukan pengujian terhadap perangkat lunak untuk evaluasi      terhadap waktu tanggap dan waktu proses Yng dibutuhkan untuk menyelesaikan      sebuah tugas.</li>
<li><em>Enviromental      Testing,</em> menguji toleransi perangkat lunak terhadap suhu, kelembaban,      gerak dan perpindahan.</li>
<li><em>Human      Factor Testing</em>, menguji antarmuka perangkat lunak bersama-sama dengan      pemakai.</li>
</ul>
<p><strong><span style="text-decoration:underline;">Interface Testing (<em>pengujian interface</em>)</span></strong></p>
<ul>
<li>Dilakukan      ketika modul atau subsistem diintegrasi untuk membuat sistem yang lebih      besar.</li>
<li>Setiap      modul atau subsistem memiliki interface yang terdifinisi yang dipanggil      oleh komponen program lain.</li>
<li>Tujuannya      adalah untuk mendeteksi kesalahan yang mungkin telah masuk ke dalam sistem      karena eror interface atau asumsi invalid mengenai interface.</li>
<li>Penting      untuk pengembangan berorientasi objek</li>
</ul>
<p><strong>OBJECT ORIENTED TESTING (<em>pengujian berorientasi objek</em>)</strong></p>
<ul>
<li><em>Pengujian operasi individual yang berhubungan dengan objek</em>. Merupakan fungsi atau prosedur dan dapat digunakan pendekatan black-box dan white-box.</li>
<li><em>Pengujian kelas objek individu</em>. Prinsip pengujian black-box tidak berubah tetapi pengertian kelas ekuivalensi harus diperluas untuk mencakup rangkaian operasi yang berhubungan. Dengan cara yang sama, pengujian struktural membutuhkan jenis analisis yang berbeda.</li>
<li><em>Pengujian kelompok objek</em>. Integrasi top-down dan bottom-up yang ketat tidak sesuai untuk membuat kumpulan objek yang berhubungan. Pengujian berdasar skenario yang digunakan.</li>
<li><em>Pengujian sistem berorientasi objek</em>. Verifikasi dan validasi terhadap spesifikasi persyaratan sistem dilakukan dengan cara yang tepat sama sebagaimana untuk jenis sistem yang lain.</li>
</ul>
<p><strong>Object Integration (integrasi objek)</strong></p>
<ul>
<li><em>Pengujian use-case atau basis skenario.</em> Mendeskripsikan satu model penggunaan sistem. Pengujian dapat didasarkan atas deskripsi skenario ini dan kelompok objek yang dibuat untuk mendukung use-case yang berhubungan dengan model penggunaan tersebut.</li>
<li><em>Pengujian thread</em>. Berdasar pengujian respon sistem terhadap suatu input atau set event input tertentu. Sistem berorientasi objek seringkali dikendalikan event sehingga merupakan bentuk pengujian yang sesuai. Untuk memakai pendekatan ini, kita harus mengidentifikasi cara pemrosesan event menelusuri jalannya melalui sistem.</li>
<li><em>Pengujian interaksi objek. </em>
<ul>
<li>Diusulkan oleh Jorgensen dan Erikson.</li>
<li>Tingkat menengah dari pengujian integrasi dapat didasarkan atas identifikasi jalur.</li>
<li>Jalur melalui serangkaian interaksi objek yang berhenti ketika operasi objek tidak memanggil &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; layanan objek lain.</li>
</ul>
</li>
</ul>
<p>Tiga hal yang harus dilakukan untuk menguji sistem OO&nbsp; :</p>
<ol>
<li>Definisi pengujian harus      diperluas untuk mencakup teknik penemuan kesalahan yang diaplikasikan ke      model OOA dan OOD.</li>
<li>Strategi untuk pengujian      unit dan terintegrasi harus berubah secara signifikan.</li>
<li>Desain test case harus      bertanggung jawab terhadap karakteristik unik perangkat lunak OO.</li>
</ol>
<p><strong>Model Pengujian OOA dan OOD</strong></p>
<ul>
<li>Model desain dan analisis      tidak dapat diuji dalam arti yang konvensional, karena model tersebut tidak      dapat dieksekusi.</li>
<li>Kajian teknis formal      dapat digunakan untuk menguji kebenaran dan konsistensi model analisis maupun      model desain.</li>
</ul>
<p><span style="text-decoration:underline;">Kebenaran Model OOA dan OOD</span></p>
<ul>
<li>Notasi dan sintaks digunakan untuk merespresentasikan model analisis dan desain.</li>
<li>Kebenaran sintaks dinilai pada penggunaan simbol yang teratur.</li>
<li>Masinag-masig model dikaji untuk memastikan apakah konvensi pemodelan yang tepat telah terjaga.</li>
</ul>
<p><span style="text-decoration:underline;">Konsistensi Model OOA dan OOD</span></p>
<ul>
<li>mempertimbangkan hubungan antar entitas di dalam model tersebut.</li>
<li>masing-masing kelas dan koneksinya ke kelas lain harus diuji.</li>
<li>desain sistem dikaji dengan menguji model tingkah laku objek yang dikembangkan selama OOA.</li>
</ul>
<p><strong>Metode Pengujian Berorientasi Objek </strong></p>
<p>Pengujian sistem berorientasi objek umumnya dilakukan secara bottom-up dalam empat level&nbsp; :</p>
<ol>
<li>Pengujian level metode      yang menguji metode  individu di      kelas.</li>
<li>Metode-metode dan      atribut-atribut yang menyusun kelas. Pengujian level kelas (intra kelas)      adalah pengujian terhadap interaksi-interaksi di antara komponen-komponen      di satu kelas individu.</li>
<li>Kelas-kelas yang bekerja      sama menyusun tandan kelas (class cluster). Pengujian tandan kelas menguji      interaksi-interaksi di antara kelas-kelas.</li>
<li>Tandan-tandan kelas      menyusun sistem. Pengujian level sistem berurusan dengan masukan dan &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keluaran yang tampak bagi      pemakai sistem.</li>
</ol>
<p><strong>Stratregi pengujian berorientasi objek </strong></p>
<p>Strategi klasik pengujian perangkat lunak&nbsp; :</p>
<ul>
<li>Dimulai dari pengujian unit, bergerak menuju pengujian integrasi dan berakhir pada validasi dan &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pengujian sistem.</li>
<li>Pengujian unit berfokus pada satuan program kecil yang dapat di-compile.</li>
<li>Unit diintegrasikan dengan suatu struktur program.</li>
<li>Pengujian regresi dijalankan untuk mengungkap kesalahan sehubungan dengan interfacing modul dan efek samping yang disebabkan oleh penambahan unit-unit baru.</li>
<li>Sistem secara keseluruhan diuji untuk memastikan apakah kesalahan terungkap.</li>
</ul>
<p>Perubahan strategi pengujian pada pendekatan berorientasi objek</p>
<ul>
<li>Pengujian unit, monsep mengenai unit diperluas di sistem berorientasi objek.</li>
<li>Pengujian integrasi, integrasi berfokus pada kelas-kelas dan eksekusinya pada satu thread atau use case.</li>
</ul>
<p>Pengujian validasi, menggunakan pengujian kotak hitam tradisional</p>
<p><strong><br>
</strong></p>
<p style="text-align:left;"><strong><br>
</strong></p>
<div id="jp-post-flair" class="sharedaddy sd-like-enabled"><div class="sharedaddy sd-block sd-like jetpack-likes-widget-wrapper jetpack-likes-widget-loaded" id="like-post-wrapper-7914973-154-5343e4bb94230" data-src="//widgets.wp.com/likes/#blog_id=7914973&amp;post_id=154&amp;origin=giyantoaudi.wordpress.com&amp;obj_id=7914973-154-5343e4bb94230" data-name="like-post-frame-7914973-154-5343e4bb94230"><h3 class="sd-title">Sukai ini:</h3><div class="likes-widget-placeholder post-likes-widget-placeholder" style="height: 55px; display: none;"><span class="button"><span>Suka</span></span> <span class="loading">Memuat...</span></div><iframe class="post-likes-widget jetpack-likes-widget" name="like-post-frame-7914973-154-5343e4bb94230" height="55px" width="100%" frameborder="0" src="./Materi Testing   Giyantoaudi's Blog_files/saved_resource.htm"></iframe><span class="sd-text-color"></span><a class="sd-link-color"></a></div></div>										

				</div>
			</div>


		</div><!-- End content -->

	</div></div><!-- End narrowcolumnwrapper and narrowcolumn classes -->

	
	</div><!-- End wrapper class -->

	<div class="sidebar">
	<ul>

<li id="text-6" class="widget widget_text">			<div class="textwidget"><a href="http://giyantoaudi.files.wordpress.com/2009/10/logo-urindo.jpg" sl-processed="1"><img src="http://giyantoaudi.files.wordpress.com/2009/10/logo-urindo.jpg" alt="" title="LOGO URINDO" width="150" height="150" class="aligncenter size-full wp-image-193"></a></div>
		</li>
<li id="text-7" class="widget widget_text">			<div class="textwidget"><img style="visibility:hidden;width:0;height:0;" border="0" width="0" height="0" src="http://counters.gigya.com/wildfire/IMP/CXNID=2000002.0NXC/bHQ9MTI2MTQ1NDk3MzM*MyZwdD*xMjYxNDU*OTk1NjI1JnA9MjIzMDUyJmQ9Jm49d29yZHByZXNzJmc9MSZvPWM2NmYwY2JmMTg2ZjRkMjJiNGQ1OGNjOGExOWVkZDI3Jm9mPTA=.gif"><iframe frameborder="0" width="170" height="165" src="./Materi Testing   Giyantoaudi's Blog_files/saved_resource(2).htm" id="wpcom-iframe-0516f8da2c0b11b727e184bdd18ff953"></iframe><br><a href="http://widgia.com/" target="_blank" style="font-size:10px;font-family:verdana;" sl-processed="1">A Widgia Widget</a></div>
		</li>
<li id="linkcat-7731" class="widget widget_links"><h2 class="widgettitle">E-mail</h2>

	<ul class="xoxo blogroll">
<li><a href="https://mail.google.com/" title="webmail firstmedia" sl-processed="1">gmail</a></li>
<li><a href="https://login.yahoo.com/config/mail?.src=ym&.intl=us" sl-processed="1">yahoo-mail</a></li>

	</ul>
</li>

<li id="linkcat-235072" class="widget widget_links"><h2 class="widgettitle">Pencarian</h2>

	<ul class="xoxo blogroll">
<li><a href="http://www.google.co.id/" title="mesin pencari" sl-processed="1">google</a></li>

	</ul>
</li>

<li id="linkcat-4390668" class="widget widget_links"><h2 class="widgettitle">Website Penting</h2>

	<ul class="xoxo blogroll">
<li><a href="http://www.didiksetiyadi.com/" title="web site Bp. Didik Setiadi (Dosen Pengajar Materi SBD URINDO)" sl-processed="1">Dosen Sistem Basis Data</a></li>
<li><a href="http://sites.google.com/a/andipensil.com/kuliah-pemrograman-java-kelas-b/" sl-processed="1">Kelas B Program Java</a></li>
<li><a href="http://www.firstmedia.com/" title="Bagi yang ingin berlangganan Fastnet bisa menghubungi saya di 021 68097332 atau giyanto.audi@firstmedia.com" sl-processed="1">www.firstmedia.com</a></li>

	</ul>
</li>


</ul>
	</div>
</div><!-- End pagewrapper -->

<div id="footer">
<p><a href="http://id.wordpress.com/?ref=footer" sl-processed="1">Blog pada WordPress.com</a>. <a href="http://theme.wordpress.com/themes/digg3/" title="Learn more about this theme" sl-processed="1">The Digg 3 Column Theme</a>.</p>
</div>

</div><!-- end page -->

</div><!-- End container id -->

<script type="text/javascript" src="./Materi Testing   Giyantoaudi's Blog_files/gprofiles.js"></script>
<script type="text/javascript">
/* <![CDATA[ */
var WPGroHo = {"my_hash":""};
/* ]]> */
</script>
<script type="text/javascript" src="./Materi Testing   Giyantoaudi's Blog_files/wpgroho.js"></script>

	<script>
		//initialize and attach hovercards to all gravatars
		jQuery( document ).ready( function( $ ) {
			Gravatar.profile_cb = function( hash, id ) {
				WPGroHo.syncProfileData( hash, id );
			};
			Gravatar.my_hash = WPGroHo.my_hash;
			Gravatar.init( 'body', '#wp-admin-bar-my-account' );
		});
	</script>

		<div style="display:none">
	</div>

	<div id="bit" class="loggedout-follow-normal" style="bottom: -265px;">
		<a class="bsub" href="javascript:void(0)" sl-processed="1"><span id="bsub-text">Ikuti</span></a>
		<div id="bitsubscribe">

					<h3><label for="loggedout-follow-field">Follow “Giyantoaudi's Blog”</label></h3>

			<form action="https://subscribe.wordpress.com/" method="post" accept-charset="utf-8" id="loggedout-follow">
			<p>Get every new post delivered to your Inbox.</p>

			<p id="loggedout-follow-error" style="display: none;"></p>

			
			<p><input type="email" name="email" value="Enter your email address" onfocus="this.value=(this.value==&quot;Enter your email address&quot;) ? &quot;&quot; : this.value;" onblur="this.value=(this.value==&quot;&quot;) ? &quot;Enter email address&quot; : this.value;" id="loggedout-follow-field"></p>

			<input type="hidden" name="action" value="subscribe">
			<input type="hidden" name="blog_id" value="7914973">
			<input type="hidden" name="source" value="http://giyantoaudi.wordpress.com/motivasi/">
			<input type="hidden" name="sub-type" value="loggedout-follow">

			<input type="hidden" id="_wpnonce" name="_wpnonce" value="075653006b"><input type="hidden" name="_wp_http_referer" value="/motivasi/">
			<p id="bsub-subscribe-button"><input type="submit" value="Sign me up"></p>
			</form>
					<div id="bsub-credit"><a href="http://wordpress.com/signup/?ref=lof" sl-processed="1">Powered by WordPress.com</a></div>
		</div><!-- #bitsubscribe -->
	</div><!-- #bit -->
	<script type="text/javascript">
	var skimlinks_pub_id = "725X584219"
	var skimlinks_sitename = "giyantoaudi.wordpress.com";
	</script>
	<script type="text/javascript" src="./Materi Testing   Giyantoaudi's Blog_files/725X1342.skimlinks.js"></script>		<iframe src="./Materi Testing   Giyantoaudi's Blog_files/master.htm" scrolling="no" id="likes-master" name="likes-master" style="display:none;"></iframe>
		<div id="likes-other-gravatars"><div class="likes-text"><span>%d</span> bloggers like this:</div><ul class="wpl-avatars sd-like-gravatars"></ul></div>
		<script type="text/javascript">
		//<![CDATA[
			var jetpackLikesWidgetQueue = [];
			var jetpackLikesWidgetBatch = [];
			var jetpackLikesMasterReady = false;

			function JetpackLikespostMessage( message, target ) {
				if ( "string" === typeof message ){
					try{
						message = JSON.parse( message );
					}
					catch(e) {
						return;
					}
				}

				pm( {
					target: target,
					type: 'likesMessage',
					data: message,
					origin: '*'
				} );
			}

			function JetpackLikesBatchHandler() {
				var requests = [];
				jQuery( 'div.jetpack-likes-widget-unloaded' ).each( function( i ) {
					if ( jetpackLikesWidgetBatch.indexOf( this.id ) > -1 )
						return;
					jetpackLikesWidgetBatch.push( this.id );
					var regex = /like-(post|comment)-wrapper-(\d+)-(\d+)-(\w+)/;
					var match = regex.exec( this.id );
					if ( ! match || match.length != 5 )
						return;

					var info = {
						blog_id: match[2],
						width:   this.width
					};

					if ( 'post' == match[1] ) {
						info.post_id = match[3];
					} else if ( 'comment' == match[1] ) {
						info.comment_id = match[3];
					}

					info.obj_id = match[4];

					requests.push( info );
				});

				if ( requests.length > 0 ) {
					JetpackLikespostMessage( { event: 'initialBatch', requests: requests }, window.frames['likes-master'] );
				}
			}

			function JetpackLikesMessageListener( event ) {
				if ( "undefined" == typeof event.event )
					return;

				if ( 'masterReady' == event.event ) {
					jQuery( document ).ready( function() {
						jetpackLikesMasterReady = true;

						var stylesData = {
								event: 'injectStyles'
						};

						if ( jQuery( 'iframe.admin-bar-likes-widget' ).length > 0 ) {
							JetpackLikespostMessage( { event: 'adminBarEnabled' }, window.frames[ 'likes-master' ] );

							stylesData.adminBarStyles = {
								background: jQuery( '#wpadminbar .quicklinks li#wp-admin-bar-wpl-like > a' ).css( 'background' ),
								isRtl: ( 'rtl' == jQuery( '#wpadminbar' ).css( 'direction' ) )
							};
						}

						if ( !window.addEventListener )
							jQuery( '#wp-admin-bar-admin-bar-likes-widget' ).hide();

						stylesData.textStyles = {
							color: jQuery( '.sd-text-color').css( 'color' ),
							fontFamily: jQuery( '.sd-text-color' ).css( 'font-family' ),
							fontSize: jQuery( '.sd-text-color' ).css( 'font-size' ),
							direction: jQuery( '.sd-text-color' ).css( 'direction' ),
							fontWeight: jQuery( '.sd-text-color' ).css( 'font-weight' ),
							fontStyle: jQuery( '.sd-text-color' ).css( 'font-style' ),
							textDecoration: jQuery( '.sd-text-color' ).css('text-decoration')
						};

						stylesData.linkStyles = {
							color: jQuery( '.sd-link-color' ).css('color'),
							fontFamily: jQuery( '.sd-link-color' ).css('font-family'),
							fontSize: jQuery( '.sd-link-color' ).css('font-size'),
							textDecoration: jQuery( '.sd-link-color' ).css('text-decoration'),
							fontWeight: jQuery( '.sd-link-color' ).css( 'font-weight' ),
							fontStyle: jQuery( '.sd-link-color' ).css( 'font-style' )
						};

						JetpackLikespostMessage( stylesData, window.frames[ 'likes-master' ] );

						JetpackLikesBatchHandler();

						jQuery( document ).on( 'inview', 'div.jetpack-likes-widget-unloaded', function() {
							jetpackLikesWidgetQueue.push( this.id );
						});
					});
				}

				if ( 'showLikeWidget' == event.event ) {
					jQuery( '#' + event.id + ' .post-likes-widget-placeholder'  ).fadeOut( 'fast', function() {
						jQuery( '#' + event.id + ' .post-likes-widget' ).fadeIn( 'fast', function() {
							JetpackLikespostMessage( { event: 'likeWidgetDisplayed', blog_id: event.blog_id, post_id: event.post_id, obj_id: event.obj_id }, window.frames['likes-master'] );
						});
					});
				}

				if ( 'clickReblogFlair' == event.event ) {
					wpcom_reblog.toggle_reblog_box_flair( event.obj_id );
				}

				if ( 'showOtherGravatars' == event.event ) {
					var $container = jQuery( '#likes-other-gravatars' );
					var $list = $container.find( 'ul' );

					$container.hide();
					$list.html( '' );

					$container.find( '.likes-text span' ).text( event.total );

					jQuery.each( event.likers, function( i, liker ) {
						$list.append( '<li class="' + liker.css_class + '"><a href="' + liker.profile_URL + '" class="wpl-liker" rel="nofollow" target="_parent"><img src="' + liker.avatar_URL + '" alt="' + liker.name + '" width="30" height="30" style="padding-right: 3px;" /></a></li>');
					} );

					var offset = jQuery( "[name='" + event.parent + "']" ).offset();

					$container.css( 'left', offset.left + event.position.left - 10 + 'px' );
					$container.css( 'top', offset.top + event.position.top - 33 + 'px' );

					var rowLength = Math.floor( event.width / 37 );
					var height = ( Math.ceil( event.likers.length / rowLength ) * 37 ) + 13;
					if ( height > 204 ) {
						height = 204;
					}

					$container.css( 'height', height + 'px' );
					$container.css( 'width', rowLength * 37 - 7 + 'px' );

					$list.css( 'width', rowLength * 37 + 'px' );

					$container.fadeIn( 'slow' );

					var scrollbarWidth = $list[0].offsetWidth - $list[0].clientWidth;
					if ( scrollbarWidth > 0 ) {
						$container.width( $container.width() + scrollbarWidth );
						$list.width( $list.width() + scrollbarWidth );
					}
				}
			}

			pm.bind( 'likesMessage', function(e) { JetpackLikesMessageListener(e); } );

			jQuery( document ).click( function( e ) {
				var $container = jQuery( '#likes-other-gravatars' );

				if ( $container.has( e.target ).length === 0 ) {
					$container.fadeOut( 'slow' );
				}
			});

			function JetpackLikesWidgetQueueHandler() {
				var wrapperID;
				if ( ! jetpackLikesMasterReady ) {
					setTimeout( JetpackLikesWidgetQueueHandler, 500 );
					return;
				}

				if ( jetpackLikesWidgetQueue.length > 0 ) {
					// We may have a widget that needs creating now
					var found = false;
					while( jetpackLikesWidgetQueue.length > 0 ) {
						// Grab the first member of the queue that isn't already loading.
						wrapperID = jetpackLikesWidgetQueue.splice( 0, 1 )[0];
						if ( jQuery( '#' + wrapperID ).hasClass( 'jetpack-likes-widget-unloaded' ) ) {
							found = true;
							break;
						}
					}
					if ( ! found ) {
						setTimeout( JetpackLikesWidgetQueueHandler, 500 );
						return;
					}
				} else if ( jQuery( 'div.jetpack-likes-widget-unloaded' ).length > 0 ) {
					// Grab any unloaded widgets for a batch request
					JetpackLikesBatchHandler();

					// Get the next unloaded widget
					wrapperID = jQuery( 'div.jetpack-likes-widget-unloaded' ).first()[0].id;
					if ( ! wrapperID ) {
						// Everything is currently loaded
						setTimeout( JetpackLikesWidgetQueueHandler, 500 );
						return;
					}
				}

				if ( 'undefined' === typeof wrapperID ) {
					setTimeout( JetpackLikesWidgetQueueHandler, 500 );
					return;
				}

				var $wrapper = jQuery( '#' + wrapperID );
				$wrapper.find( 'iframe' ).remove();

				if ( $wrapper.hasClass( 'slim-likes-widget' ) ) {
					$wrapper.find( '.post-likes-widget-placeholder' ).after( "<iframe class='post-likes-widget jetpack-likes-widget' name='" + $wrapper.data( 'name' ) + "' height='22px' width='68px' frameBorder='0' scrolling='no' src='" + $wrapper.data( 'src' ) + "'></iframe>" );
				} else {
					$wrapper.find( '.post-likes-widget-placeholder' ).after( "<iframe class='post-likes-widget jetpack-likes-widget' name='" + $wrapper.data( 'name' ) + "' height='55px' width='100%' frameBorder='0' src='" + $wrapper.data( 'src' ) + "'></iframe>" );
				}

				$wrapper.removeClass( 'jetpack-likes-widget-unloaded' ).addClass( 'jetpack-likes-widget-loading' );

				$wrapper.find( 'iframe' ).load( function( e ) {
					var $iframe = jQuery( e.target );
					$wrapper.removeClass( 'jetpack-likes-widget-loading' ).addClass( 'jetpack-likes-widget-loaded' );

					JetpackLikespostMessage( { event: 'loadLikeWidget', name: $iframe.attr( 'name' ), width: $iframe.width() }, window.frames[ 'likes-master' ] );

					if ( $wrapper.hasClass( 'slim-likes-widget' ) ) {
						$wrapper.find( 'iframe' ).Jetpack( 'resizeable' );
					}
				});
				setTimeout( JetpackLikesWidgetQueueHandler, 250 );
			}
			JetpackLikesWidgetQueueHandler();
		//]]>
		</script>
<script type="text/javascript" src="./Materi Testing   Giyantoaudi's Blog_files/devicepx.js"></script>
<script type="text/javascript">
// <![CDATA[
(function() {
try{
  if ( window.external &&'msIsSiteMode' in window.external) {
    if (window.external.msIsSiteMode()) {
      var jl = document.createElement('script');
      jl.type='text/javascript';
      jl.async=true;
      jl.src='/wp-content/plugins/ie-sitemode/custom-jumplist.php';
      var s = document.getElementsByTagName('script')[0];
      s.parentNode.insertBefore(jl, s);
    }
  }
}catch(e){}
})();
// ]]>
</script><script src="./Materi Testing   Giyantoaudi's Blog_files/w.js" type="text/javascript"></script>
<script type="text/javascript">
st_go({'blog':'7914973','v':'wpcom','tz':'0','user_id':'0','post':'154','subd':'giyantoaudi'});
ex_go({'crypt':'UE40eW5QN0p8M2Y/RE1LVmwrVi5vQS5fVFtfdHBbPyw1VXIrU3hWLHhzVndTdktBX0ddJnpXRjVaOTd6fj1YMX4ydzR6MmRCYnxkNmc1Z2RNY3xBUDlQdnFdM1FrbyZ2U0g9ZGZBfGxzQ198W11tJTF1dGRWOF02dUw2NUVBLEpqSnVLZ0hQWGVXaWxXZWNmYUZVUS45SmNEUWFIJUEuSEZIQTVYLVZKSTRvW01wSXhMdDdkb1RWWjMrXy8wUDR5ak5adCtHSWtPLE5lenBpSGxEZGJiVHImLyVsOEcrZnMrNE00X1g2d2JWa0Q4JlRncU5URXxiVV0lVzVjTGdIdW1NajE='});
addLoadEvent(function(){linktracker_init('7914973',154);});
	</script><img id="wpstats" src="http://stats.wordpress.com/g.gif?host=giyantoaudi.wordpress.com&rand=0.7896833347622305&blog=7914973&v=wpcom&tz=0&user_id=0&post=154&subd=giyantoaudi&ref=https%3A//www.google.com/" alt=""><img id="wpstats2" src="http://stats.wordpress.com/g.gif?v=wpcom-no-pv&rand=0.9162722281180322&crypt=UE40eW5QN0p8M2Y/RE1LVmwrVi5vQS5fVFtfdHBbPyw1VXIrU3hWLHhzVndTdktBX0ddJnpXRjVaOTd6fj1YMX4ydzR6MmRCYnxkNmc1Z2RNY3xBUDlQdnFdM1FrbyZ2U0g9ZGZBfGxzQ198W11tJTF1dGRWOF02dUw2NUVBLEpqSnVLZ0hQWGVXaWxXZWNmYUZVUS45SmNEUWFIJUEuSEZIQTVYLVZKSTRvW01wSXhMdDdkb1RWWjMrXy8wUDR5ak5adCtHSWtPLE5lenBpSGxEZGJiVHImLyVsOEcrZnMrNE00X1g2d2JWa0Q4JlRncU5URXxiVV0lVzVjTGdIdW1NajE%3D" alt="" style="display:none">
<noscript>&lt;img src="http://stats.wordpress.com/b.gif?v=noscript" style="height:0px;width:0px;overflow:hidden" alt="" /&gt;</noscript>
<script>
if ( 'object' === typeof wpcom_mobile_user_agent_info ) {

	wpcom_mobile_user_agent_info.init();
	var mobileStatsQueryString = "";
	
	if( false !== wpcom_mobile_user_agent_info.matchedPlatformName )
		mobileStatsQueryString += "&x_" + 'mobile_platforms' + '=' + wpcom_mobile_user_agent_info.matchedPlatformName;
	
	if( false !== wpcom_mobile_user_agent_info.matchedUserAgentName )
		mobileStatsQueryString += "&x_" + 'mobile_devices' + '=' + wpcom_mobile_user_agent_info.matchedUserAgentName;
	
	if( wpcom_mobile_user_agent_info.isIPad() )
		mobileStatsQueryString += "&x_" + 'ipad_views' + '=' + 'views';

	if( "" != mobileStatsQueryString ) {
		new Image().src = document.location.protocol + '//stats.wordpress.com/g.gif?v=wpcom-no-pv' + mobileStatsQueryString + '&baba=' + Math.random();
	}
	
}
</script>


</body></html>