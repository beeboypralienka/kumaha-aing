<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0060)http://scifoanggi.students-blog.undip.ac.id/tag/gui-testing/ -->
<html xmlns="http://www.w3.org/1999/xhtml"><head profile="http://gmpg.org/xfn/11"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	
	<title>Scifo Anggi Yudianto » GUI testing</title>
	
	<link rel="alternate" type="application/rss+xml" title="RSS for posts" href="http://scifoanggi.students-blog.undip.ac.id/feed/">
	<link rel="alternate" type="application/rss+xml" title="RSS for comments" href="http://scifoanggi.students-blog.undip.ac.id/comments/feed/">
	
	<meta name="description" content="">
	<meta name="keywords" content="">
	
	<link rel="stylesheet" href="./Scifo Anggi Yudianto » GUI testing_files/style.css" type="text/css" media="screen">
	
		<link rel="alternate" type="application/rss+xml" title="Scifo Anggi Yudianto » GUI testing Tag Feed" href="http://scifoanggi.students-blog.undip.ac.id/tag/gui-testing/feed/">
<link rel="stylesheet" id="bp-admin-bar-css" href="./Scifo Anggi Yudianto » GUI testing_files/adminbar.css" type="text/css" media="all">
<link rel="stylesheet" id="bp-chat-shoutbox-css-css" href="./Scifo Anggi Yudianto » GUI testing_files/shoutbox.css" type="text/css" media="all">
<link rel="stylesheet" id="bp-chat-structure-css" href="./Scifo Anggi Yudianto » GUI testing_files/structure.css" type="text/css" media="all">
<link rel="stylesheet" id="bp-chat-nifty-css-css" href="./Scifo Anggi Yudianto » GUI testing_files/nifty.css" type="text/css" media="all">
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/l10n.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/jquery.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/jqDnR.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/dimensions.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/jqModal.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/nifty.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/move_chat.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/bp-like.min.js"></script>
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://scifoanggi.students-blog.undip.ac.id/xmlrpc.php?rsd">
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="http://scifoanggi.students-blog.undip.ac.id/wp-includes/wlwmanifest.xml"> 
<link rel="index" title="Scifo Anggi Yudianto" href="http://scifoanggi.students-blog.undip.ac.id/">
<meta name="generator" content="WordPress 3.1">

	<script type="text/javascript">var ajaxurl = "http://scifoanggi.students-blog.undip.ac.id/wp-load.php";</script>

<style type="text/css">
	.bp-like.activity_liked .activity-meta,
	.bp-like.blogpost_liked .activity-meta,
	.users-who-like,
	.mini a.view-likes,
	.mini a.hide-likes {
		display: none;
	}
	
	/* To match the default theme */
	#bp-default .users-who-like {
		margin: 10px 0 -10px 0;
		background: #F5F5F5;
		-moz-border-radius: 4px;
		-webkit-border-radius: 4px;
		border-radius: 4px;
		padding: 8px 8px 0px 12px;
		color: #8C8A8F;
	}
	#bp-default .users-who-like a {
		color: #777;
		padding: 0;
		background: none;
		border: none;
		text-decoration: underline;
		font-size: 12px;
	}
	#bp-default .users-who-like a:hover { color: #222; }
	#bp-default .mini .users-who-like {
		width: 100%;
		position: absolute;
		top: 0;
		left: 0;
	}
	#bp-default .users-who-like img.avatar {
		float: none;
		border: none;
		width: 30px;
		height: 30px;
		padding: 0;
		margin: 0;
	}
	ul#activity-stream li.bp-like .activity-inner {
		border-left: 3px solid #ddd;
		color: #888;
		padding-left: 15px;
		font-style: italic;
	}
	#bp-default div.post div.author-box, div.comment-avatar-box {
	position: relative;
	}
	#bp-default div.like-box {
		background: #f0f0f0;
		width: 90px;
		position: absolute;
		bottom: -40px;
		left: 0;
		font-family: georgia, times, serif;
		font-style: italic;
		text-align: center;
		padding: 5px 0;
		-moz-border-radius: 3px;
		-webkit-border-radius: 3px;
		border-radius: 3px;
	}
</style>
<script type="text/javascript">
/* <![CDATA[ */
	var bp_like_terms_like = 'Like';
	var bp_like_terms_like_message = 'Like this item';
	var bp_like_terms_unlike_message = 'Unlike this item';
	var bp_like_terms_view_likes = 'View likes';
	var bp_like_terms_hide_likes = 'Hide likes';
	var bp_like_terms_unlike_1 = 'Unlike (1)';
/* ]]> */
</script>

	<style type="text/css" media="screen">
	a#ribbon {
	position: absolute;
	top: 0px;
	right: 0px;
	display: block;
	width: 129px;
	height: 129px;
	background: transparent url("http://scifoanggi.students-blog.undip.ac.id/wp-content/plugins/nofollow-free/images/css_nofollow_badgeredright.gif") no-repeat top left;
	text-indent: -999em;
	text-decoration: none;
	z-index: 1000;
	}
	</style>
<link rel="stylesheet" href="./Scifo Anggi Yudianto » GUI testing_files/wppa_style.css" type="text/css" media="screen">
		<link rel="stylesheet" id="bp-album-css-css" href="./Scifo Anggi Yudianto » GUI testing_files/general.css" type="text/css" media="all">
<style type="text/css">
#aka,#aka:link,#aka:hover,#aka:visited,#aka:active{color:#fff;text-decoration:none}
#aka:hover{border:none;text-decoration:none}
#aka:hover #akismet1{display:none}
#aka:hover #akismet2,#akismet1{display:block}
#akismet2{display:none;padding-top:2px}
#akismeta{font-size:16px;font-weight:bold;line-height:18px;text-decoration:none}
#akismetcount{display:block;font:15px Verdana,Arial,Sans-Serif;font-weight:bold;text-decoration:none}
#akismetwrap #akismetstats{background:url(http://scifoanggi.students-blog.undip.ac.id/wp-content/plugins/akismet/akismet.gif) no-repeat top left;border:none;color:#fff;font:11px 'Trebuchet MS','Myriad Pro',sans-serif;height:40px;line-height:100%;overflow:hidden;padding:8px 0 0;text-align:center;width:120px}
</style>
		    
	</head>    
	<body>
<div id="header">
	<div id="header-inner">
		<h1 id="title">
			<a href="http://scifoanggi.students-blog.undip.ac.id/">Scifo Anggi Yudianto</a>
		</h1>
		<div id="description">
			blog yang dibuat karena persyaratan mata kuliah		</div>
		<div class="clear"></div>
	</div>
</div>
<!-- END OF HEADER -->
<div id="menu">
	<div id="menu-inner">
		<ul class="menu">
			<li class="page_item"><a href="http://scifoanggi.students-blog.undip.ac.id/" title="Visit Home">Home</a></li>
			<li class="page_item page-item-2"><a href="http://scifoanggi.students-blog.undip.ac.id/about/" title="About">About</a></li>
		</ul>
	</div>
</div>
<div id="mid">
		<div id="mid-inner">
			<div id="box">
				<div class="breadcrumb">
									</div>
			</div>
			<div id="search">
				<form class="search" method="get" action="http://scifoanggi.students-blog.undip.ac.id/">
					<div><input id="searchword" class="inputbox" name="s" type="text" onfocus="if(this.value==&#39;search ...&#39;) this.value=&#39;&#39;;" onblur="if(this.value==&#39;&#39;) this.value=&#39;search ...&#39;;" value="search ..." size="20" maxlength="20"></div>
				</form>
			</div>
		</div>
	</div>
<!-- END OF MENU --><div id="content">
	<div id="main">
		<div id="left">
			<div id="posts">
				<h1 id="headline">
											Posts Tagged ‘GUI testing’
										</h1>
													<div class="post" id="post-56">
					<h2 class="post-title">
						<a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/14/resume-jurnal-on-the-test-case-definition-for-gui-testing/" rel="bookmark" title="Permanent Link to Resume jurnal : On the Test Case Definition for GUI Testing">Resume jurnal : On the Test Case Definition for GUI Testing</a>
					</h2>
					<div class="post-info">
						<span class="post-date">November 14, 2010</span>
						<span class="post-comments"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/14/resume-jurnal-on-the-test-case-definition-for-gui-testing/#respond" title="Comment on Resume jurnal : On the Test Case Definition for GUI Testing">0 comment</a></span>
					</div>
					<div class="post-content">
								<p>Berikut merupakan hasil resume saya tentang jurnal tersebut, jurnal tersebut bisa di download <a href="http://www.computer.org/portal/web/csdl/doi/10.1109/QSIC.2005.45">disini.</a></p>
<p><strong>Title</strong></p>
<p style="text-align: justify">On the Test Case Definition for GUI Testing</p>
<p><strong>Authors</strong></p>
<p style="text-align: justify">Kai-Yuan Cai, Lei Zhao, Hai Hu and Chang-Hai Jiang, Department of Automatic Control, Beijing University of Aeronautics and Astronautics</p>
<p><strong>Abstract</strong></p>
<p style="text-align: justify">GUI Testing adalah daerah berkembang penting, menghadapi sejumlah tantangan berat. Beberapa metode telah diajukan untuk testing GUI. Namun masih belum jelas bagaimana mendefinisikan kasus GUI test dan berapa banyak tindakan harus terdiri dari batu ujian GUI. Dalam tulisan ini kami mengusulkan suatu pendekatan yang mendefinisikan GUI kasus uji sebagai urutan tindakan GUI primitif dan memperlakukan suite GUI tes sebagai hirarki dalam bahasa formal. Ini bukan hanya teori utuh, tetapi juga praktis nyaman. Dimensi dari test suite GUI dan urutan kasus uji GUI dapat didefinisikan secara unik. Sebuah prosedur yang nyaman tersedia yang menghasilkan kasus-kasus tingkat tinggi uji dari uji kasus lebih rendah-order. percobaan testing Tiga dengan browser internet dunia nyata mengungkapkan bahwa orde kedua uji kasus dapat secara signifikan mengungguli uji kasus orde pertama dalam testing GUI dan harus dihasilkan untuk menjalankan fungsi tertentu GUI. Selain itu, jumlah tindakan yang diterapkan selama testing harus digunakan untuk mengganti jumlah testing yang dilakukan selama testing untuk mengevaluasi efektivitas proses testing GUI. Makalah ini menyediakan link potensial antara teori bahasa formal dan testing GUI.</p>
<p><strong>Introduction</strong></p>
<p style="text-align: justify">Graphical user interface (GUI) telah secara luas diadopsi dalam sistem perangkat lunak saat ini. GUI dapat merupakan sebanyak 45-60% dari total kode software <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.23.2987&rep=rep1&type=pdf">[1]</a>. Maka dari itu pentingnya GUI terlihat jelas <a rel="nofollow" href="http://www.amazon.com/Designing-User-Interface-Human-Computer-Interaction/dp/0321197860">[2]</a>. sejumlah definisi kasus uji dapat ditemukan dalam literatur yang ada pengujian perangkat lunak. Meyer mendefinisikan kasus uji sebagai input dengan output yang diharapkan <a href="http://portal.acm.org/citation.cfm?id=539883">[11]</a>. Binder <a rel="nofollow" href="http://www.amazon.com/Testing-Object-Oriented-Systems-Models-Patterns/dp/0201809389">[12]</a> mendefinisikan test case terdiri dari keadaan pretest perangkat lunak yang diuji (termasuk lingkungannya), urutan masukan uji, dan laporan hasil tes diharapkan. Memon et al <a href="http://ieeexplore.ieee.org/Xplore/login.jsp?url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F8780%2F27811%2F01240304.pdf%3Farnumber%3D1240304&authDecision=-203">[13]</a> mendefinisikan kasus uji terdiri dari sebuah keadaan awal dan urutan tindakan hukum.</p>
<p style="text-align: justify">Untuk aplikasi GUI, karena beberapa jendela diperbolehkan dan mungkin ada “banyak cara” dan “banyak cara keluar” penanganan jendela, uji kasus tidak dapat didefinisikan secara jelas. Jika tindakan satu pengguna atau rangkaian tindakan pengguna didefinisikan sebagai single test case? Jika suatu peristiwa yang tidak diminta atau tidak terkendali seperti tampilan jendela dialog pencetakan diperlakukan sebagai bagian dari ujian atau sebagian output melaksanakan test case? Haruskah tindakan atau peristiwa yang termasuk dalam ujian akan disinkronisasi atau tidak? Bagaimana mungkin definisi kasus uji mempengaruhi efektivitas pengujian GUI?</p>
<p style="text-align: justify">Tulisan ini bertujuan untuk mengatasi masalah definisi uji eksperimental studi kasus dan bagaimana definisi kasus uji dapat mempengaruhi efektivitas pengujian GUI. Bagian 2 tinjauan kerja terkait dalam pengujian GUI. Bagian 3 mengusulkan sebuah pendekatan untuk definisi kasus GUI tes atau generasi. Bagian 4 menjelaskan tentang aplikasi GUI diadopsi dalam percobaan kami. Bagian 5 menyajikan hasil eksperimen. Sebuah diskusi umum disajikan dalam Bagian 6. Pernyataan Penutup tercantum dalam Bagian 7.</p>
<p><strong>Method and Materials</strong></p>
<p style="text-align: justify">kami melakukan percobaan pengujian GUI dengan, freeware MyIE 3.2, yang merupakan aplikasi GUI subjek. MyIE 3.2 adalah browser tab dengan antarmuka yang dapat disesuaikan [19]. Hal ini didasarkan pada mesin browser Internet Explorer. Banyak fitur yang efisien tambahan yang disediakan dalam MyIE, seperti multi-browsing halaman, operasi tab, jendela iklan filter, menyimpan halaman web cepat, menampilkan alamat IP dan pengaturan server proxy cepat. Gambar 5.1 menunjukkan GUI dari browser. MyIE 3.2 ditulis dalam Visual C + + 6.0 (berdasarkan MFC), terdiri dari 84 kelas, 152 file, dan 49664 baris kode sumber, yang 30.374 baris yang dieksekusi.</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/2.gif" alt=""><br>
Figure 5.1 Operating User Interface of MyIE 3.2</p>
<p style="text-align: justify">Sebuah platform pengujian secara eksklusif dikembangkan untuk mengotomatisasi proses pengujian MyIE 3.2 dengan defect disuntikkan. Gambar 5.2 menunjukkan arsitektur dari platform pengujian, dimana blok perangkat lunak mengacu pada komponen 3,2 MyIE yang berisi sejumlah defect disuntikkan.</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/3.gif" alt=""><br>
Figure 5.2 Architecture of the Testing Platform</p>
<p style="text-align: justify">Proses pengujian berikut diikuti pada percobaan pengujian GUI:<br>
(1) Pilih test suite yang diinginkan, bisa yang T1, T2 atau T3<br>
(2) Menginisialisasi MyIE 3.2 dan file pendukung, sedangkan 25 defect yang disuntikkan ke dalam MyIE 3.2, dan keadaan awal tertentu diatur untuk MyIE 3.2;<br>
(3) Pilih ujian dari suite tes yang diberikan dari strategi pengujian diberikan<br>
(4) Ubah i = 1;<br>
(5) Terapkan tindakan a1 ke MyIE 3.2;<br>
(6) Jika tidak ada defect yang dipicu, lanjutkan ke Langkah (10);<br>
(7) Lepaskan defect memicu dan memperbarui file pendukung;<br>
(8) Jika kriteria tes yang diberikan berhenti merasa puas, lanjutkan ke Langkah (14);<br>
(9) Pergi ke Langkah (4);<br>
(10) Update file pendukung;<br>
(11) Jika i=  , lanjutkan ke Langkah (3);<br>
(12) Biarkan i=i+ 1;<br>
(13) Pergi ke Langkah (5);<br>
(14) Berhenti.</p>
<p><strong>Result</strong></p>
<p style="text-align: justify">Pada bagian sebelumnya kita fokus pada bagaimana cara mendefinisikan kasus uji GUI. Jawaban tidak jelas sebagai GUI test case dapat didefinisikan dalam tata krama yang berbeda dan uji kasus GUI dapat berupa tindakan yang berbeda dan nomor yang berbeda dari tindakan. Kami mengusulkan suatu pendekatan yang mendefinisikan GUI kasus uji sebagai urutan tindakan primitif dan GUI mengobati suite tes GUI sebagai bahasa hirarkis. Pendekatan ini secara teoritis solid dalam arti bahwa setiap bahasa yang hirarkis secara intrinsik memiliki hirarki yang unik dalam kanonik tertanam dan mendefinisikan suatu tatanan yang unik untuk setiap kata.</p>
<p style="text-align: justify">Pendekatan ini juga nilai praktis karena memberikan panduan untuk menghasilkan higherorder kasus uji dari uji kasus lebih rendah-order. Percobaan pengujian tiga dengan browser Internet di dunia nyata, MyIE 3.2, mengungkapkan bahwa uji kasus orde kedua yang dihasilkan untuk menjalankan fungsi tertentu GUI secara signifikan mungkin mengalahkan kasus orde pertama tes. Pentingnya kerja yang disajikan dalam makalah ini lebih lanjut dapat dibenarkan oleh potensi yang menyediakan link baru antara teori bahasa formal dan pengujian GUI.</p>
<p><strong>Discussion and Recommendations</strong></p>
<p style="text-align: justify">Dari hasil eksperimen yang telah dilakukan, penulis mendapatkan beberapa pengamatan yaitu :<br>
a.	suite tes GUI dapat diperlakukan sebagai bahasa hirarkis, di mana setiap ujian memiliki perintah yang unik. Setiap test suite GUI memiliki struktur hirarkis intrinsik atau hirarki batin. Penelitian ini secara teoritis padat dan menyediakan partisi alami suite uji untuk pengujian partisi aplikasi GUI.<br>
b.	Kasus-kasus orde kedua tes yang dihasilkan untuk menjalankan fungsi tertentu GUI jauh lebih efektif dalam mendeteksi cacat daripada yang dihasilkan secara acak dari uji kasus orde pertama.<br>
c.	Selama orde kedua uji kasus dihasilkan untuk menjalankan fungsi tertentu GUI, mereka jauh lebih efektif daripada uji kasus orde pertama<br>
d.	Tahap awal proses pengujian (sebelum 10 atau 12 cacat yang terdeteksi), suite uji beda menunjukkan kinerja yang serupa. Setelah itu, kasus-kasus orde kedua tes yang dihasilkan untuk menjalankan fungsi tertentu GUI secara signifikan mengungguli jenis lain kasus uji.<br>
e.	Jumlah pengujian yang dilakukan dalam proses pengujian mungkin tidak lagi menjadi ukuran kinerja yang tepat untuk pengujian GUI.</p>
<p><strong>References :</strong></p>
<p style="text-align: justify">Kai-Yuan Cai, Lei Zhao, Hai Hu, Chang-Hai Jiang, “<a href="http://www.computer.org/portal/web/csdl/doi/10.1109/QSIC.2005.45">On the Test Case Definition for GUI testing</a>,” in Proceedings of the Fifth International Conference on Quality Software (QSIC 2005), Melbourne, Australia, September 2005</p>
<p>Semoga bermanfaat bagi rekanz ^^b</p>
					</div>
					<span class="post-separator"></span>
				</div>
									<div class="post" id="post-51">
					<h2 class="post-title">
						<a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/14/resume-jurnal-hierarchical-gui-test-case-generation-using-automated-planning/" rel="bookmark" title="Permanent Link to Resume jurnal : Hierarchical GUI Test Case Generation Using Automated Planning">Resume jurnal : Hierarchical GUI Test Case Generation Using Automated Planning</a>
					</h2>
					<div class="post-info">
						<span class="post-date">November 14, 2010</span>
						<span class="post-comments"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/14/resume-jurnal-hierarchical-gui-test-case-generation-using-automated-planning/#respond" title="Comment on Resume jurnal : Hierarchical GUI Test Case Generation Using Automated Planning">0 comment</a></span>
					</div>
					<div class="post-content">
								<p>Berikut merupakan hasil resume saya tentang jurnal tersebut, jurnal tersebut bisa di download <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=908959">disini.</a></p>
<p><strong>Title</strong></p>
<p style="text-align: justify">Hierarchical GUI Test Case Generation Using Automated Planning</p>
<p><strong>Authors</strong></p>
<p style="text-align: justify">Atif M. Memon, Student Member, IEEE, Martha E. Pollack, and Mary Lou Soffa, Member, IEEE</p>
<p><strong>Abstract</strong></p>
<p style="text-align: justify">Meluasnya penggunaan GUI untuk berinteraksi dengan perangkat lunak mengarah ke pembangunan GUI yang lebih kompleks dan lebih. Dengan meningkatnya kompleksitas datang tantangan dalam menguji kebenaran GUI dan software yang mendasarinya. Kami menyajikan sebuah teknik baru untuk secara otomatis menghasilkan kasus uji untuk GUI yang mengeksploitasi perencanaan, teknik baik dikembangkan dan digunakan dalam kecerdasan buatan. Mengingat satu set operator, kondisi awal, dan sebuah negara tujuan, perencana menghasilkan urutan operator yang akan mengubah keadaan awal ke negara tujuan. uji kasus kami teknik generasi memungkinkan aplikasi yang efisien perencanaan dengan terlebih dahulu menciptakan sebuah model hirarkis GUI berdasarkan strukturnya. Kami menerapkan sistem uji kasus kami generasi, yang disebut Perencanaan Assisted Tester untuk antarmuka pengguna grafis Systems (PATHS) dan eksperimen dievaluasi kepraktisan dan keefektifannya. Kami menjelaskan implementasi prototipe PATHS dan melaporkan hasil eksperimen yang terkontrol untuk menghasilkan uji kasus untuk Microsoft WordPad.</p>
<p><strong>Introduction</strong></p>
<p style="text-align: justify">Graphical User Interface (GUI) telah menjadi cara yang penting dan diterima berinteraksi dengan perangkat lunak saat ini. Meskipun mereka membuat perangkat lunak mudah digunakan dari sudut pandang pengguna, mereka mempersulit proses pengembangan software <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.45.4103&rep=rep1&type=pdf">[1]</a>, <a href="http://portal.acm.org/citation.cfm?id=891025">[2]</a>. Secara khusus, pengujian GUI lebih kompleks dari pengujian perangkat lunak konvensional, karena tidak hanya perangkat lunak yang mendasari harus diuji tetapi GUI itu sendiri harus dilaksanakan dan diuji untuk memeriksa apakah itu menegaskan untuk spesifikasi GUI. Bahkan ketika alat-alat yang digunakan untuk menghasilkan GUI secara otomatis <a href="http://www.cs.cmu.edu/~bam/toolnames/">[3]</a>, [4], <a href="http://www.sciencedirect.com/science?_ob=ArticleURL&_udi=B6TYG-3SNTH1X-8&_user=10&_coverDate=02%2F28%2F1997&_rdoc=1&_fmt=high&_orig=search&_origin=search&_sort=d&_docanchor=&view=c&_searchStrId=1539846719&_rerunOrigin=google&_acct=C000050221&_version=1&_urlVersion=0&_userid=10&md5=8d2933ade10b6a411d2bb1d17ef3baf0&searchtype=a">[5]</a>, alat-alat ini sendiri mungkin mengandung kesalahan yang dapat memanifestasikan dirinya dalam GUI yang dihasilkan menyebabkan kegagalan perangkat lunak. Oleh karena itu, pengujian GUI terus tetap menjadi aspek penting dari pengujian perangkat lunak.</p>
<p style="text-align: justify">Dalam tulisan ini, kami menyajikan sebuah teknik baru untuk secara otomatis menghasilkan uji kasus untuk sistem GUI. Pendekatan kami memanfaatkan perencanaan teknik yang dikembangkan dan digunakan secara ekstensif dalam kecerdasan buatan (AI). Ide kuncinya adalah bahwa uji desainer cenderung memiliki ide yang baik dari tujuan kemungkinan pengguna GUI dan itu lebih sederhana dan lebih efektif untuk menentukan tujuan-tujuan dari untuk menentukan urutan peristiwa yang pengguna bisa menggunakan untuk mencapainya. Uji kasus kami generasi sistem, yang disebut Perencanaan Assisted Tester to Graphical User Interface Sistem (PATHS) mengambil tujuan-tujuan sebagai input dan menghasilkan urutan seperti kejadian secara otomatis.</p>
<p><strong>Method and Materials</strong></p>
<p style="text-align: justify">Sebuah prototipe PATHS dikembangkan dan beberapa set Percobaan dilakukan untuk memastikan bahwa PATHS praktis dan berguna. Percobaan ini telah dieksekusi pada komputer berbasis Pentium dengan RAM 200MB menjalankan Linux OS. Ringkasan hasil dari beberapa eksperimen diberikan dalam bagian berikut:</p>
<p><strong>5.1	Kasus Uji Membangkitkan untuk Tugas Multiple</strong></p>
<p style="text-align: justify">PATHS digunakan untuk menghasilkan uji kasus untuk Microsoft WordPad. Contoh uji kasus tingkat tinggi yang dihasilkan ditunjukkan pada Tabel 1. Jumlah kejadian GUI dalam WordPad ditetapkan menjadi sekitar 325. Setelah analisis, PATHS mengurangi set ini untuk 32-interaksi sistem dan operator abstrak, yaitu, kira-kira rasio 10: 1. Penurunan jumlah operator yang mengesankan dan membantu mempercepat proses pembuatan rencana, seperti akan ditunjukkan dalam Bagian 5.2.</p>
<p style="text-align: center">Tabel 1<br>
WordPad Beberapa Rencana yang Dibuat<br>
<img src="./Scifo Anggi Yudianto » GUI testing_files/13.gif" alt="tabel 1"></p>
<p style="text-align: left"><strong>5.2	Hirarkis vs Single-Level Test Kasus Generasi</strong></p>
<p style="text-align: justify">Pada percobaan kedua kami, kami membandingkan tes single-level generasi halnya dengan teknik uji kasus generasi hirarkis. Ingatlah bahwa dalam teknik uji kasus single-level generasi, perencanaan dilakukan pada satu tingkat abstraksi. Operator memiliki korespondensi satu-ke-satu dengan peristiwa GUI. Di sisi lain, dalam pendekatan test case generasi hirarkis, pemodelan hirarki dari operator yang digunakan.</p>
<p style="text-align: justify">Penelitian ini menunjukkan pentingnya proses pemodelan hirarki. Kunci ke generasi kasus uji efisien adalah memiliki sejumlah kecil operator perencanaan pada tiap tingkat perencanaan. Sebagai GUI menjadi lebih kompleks, algoritma pemodelan kami mampu memperoleh peningkatan jumlah tingkat abstraksi. Kami melakukan beberapa analisis eksplorasi untuk GUI yang jauh lebih besar dari Microsoft Word. Di sana, proses pemodelan otomatis mengurangi jumlah operator dengan rasio 20:1.</p>
<p><strong>Result</strong></p>
<p style="text-align: justify">Hasil penelitian ini diringkas dalam Tabel 2. Kami telah menunjukkan waktu CPU untuk enam tugas yang berbeda. Kolom 1 menunjukkan jumlah tugas; Kolom 2 menunjukkan panjang kasus uji yang dihasilkan dengan menggunakan pendekatan single-level dan Kolom 3 menunjukkan waktu CPU yang sesuai. Tugas yang sama kemudian digunakan untuk menghasilkan lain ujian tapi kali ini dengan menggunakan operator hirarkis. Kolom 4 menunjukkan panjang rencana tingkat tinggi dan Kolom 5 menunjukkan waktu yang dibutuhkan untuk menghasilkan ini rencana tingkat tinggi dan kemudian membusuk itu. Rencana 1, yang diperoleh dari algoritma hirarki, memperluas untuk memberikan rencana panjang 18, yaitu, persis rencana sama diperoleh dengan menjalankan algoritma yang sesuai single-level. Hasil waktu menunjukkan pendekatan hirarki lebih efisien daripada pendekatan single-level. Ini hasil dari jumlah yang lebih kecil dari operator yang digunakan dalam masalah perencanaan.</p>
<p style="text-align: center">TABEL 2<br>
Membandingkan Tingkat Single dengan Pendekatan hirarkis<br>
<img src="./Scifo Anggi Yudianto » GUI testing_files/23.gif" alt="tabel 2"><br>
“ – “ menunjukkan bahwa rencana tidak ditemukan dalam satu jam.</p>
<p style="text-align: justify">Kami telah menunjukkan bahwa teknik kita baik secara praktis dan berguna dengan menghasilkan kasus uji untuk MS populer WordPad perangkat lunak GUI. penelitian kami menunjukkan bahwa pendekatan perencanaan berhasil dalam menghasilkan kasus uji untuk skenario yang berbeda. Kami eksperimental menunjukkan bahwa pendekatan pemodelan hirarki itu perlu untuk secara efisien menghasilkan uji kasus.</p>
<p><strong>Discussion and Recommendations</strong></p>
<p style="text-align: justify">Kami mencatat beberapa keterbatasan saat ini pendekatan kami.<br>
•	Pertama, generator ujian sebagian besar didorong oleh pilihan tugas yang diberikan kepada perencana. Saat ini di PATHS, tugas-tugas yang dipilih secara manual oleh perancang uji. Sebuah buruk dipilih set tugas akan menghasilkan sebuah test suite yang tidak menyediakan cakupan yang memadai. Kami sedang menjajaki pengembangan tindakan cakupan untuk GUI.<br>
•	Kedua, kita sangat tergantung pada struktur hirarkis GUI untuk generasi test case efisien. Jika PATHS diberi GUI kurang terstruktur maka tidak ada operator abstrak akan diperoleh dan perencanaan akan tergantung sepenuhnya pada operator primitif, membuat sistem yang tidak efisien.<br>
•	Ketiga, pendekatan kami harus digunakan dalam hubungannya dengan teknik generasi uji kasus lain untuk menguji perangkat lunak memadai seperti umumnya halnya dengan generator tes yang paling kasus.</p>
<p style="text-align: justify">Salah satu tugas yang saat ini dilakukan oleh perancang tes adalah definisi dari prakondisi dan efek dari operator. Definisi seperti operator yang biasa digunakan dapat dipertahankan di perpustakaan, sehingga membuat tugas ini lebih mudah. Kami juga sedang menyelidiki bagaimana untuk secara otomatis menghasilkan prakondisi dan efek dari operator dari spesifikasi GUI’s.</p>
<p><strong>References :</strong></p>
<p style="text-align: justify">A.M.Memon, M.E.Pollack, M.L.Soffa, “<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=908959">Hierarchical GUI Test Case Generation Using Automated Planning</a>”, IEEE Transactions on Software Engineering, Vol.27, No.2, 2001.</p>
<p>Semoga bermanfaat bagi rekanz ^^b</p>
					</div>
					<span class="post-separator"></span>
				</div>
									<div class="post" id="post-49">
					<h2 class="post-title">
						<a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/13/resume-jurnal-generating-event-sequence-based-test-cases-using-gui-runtime-state-feedback/" rel="bookmark" title="Permanent Link to Resume Jurnal : Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback">Resume Jurnal : Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback</a>
					</h2>
					<div class="post-info">
						<span class="post-date">November 13, 2010</span>
						<span class="post-comments"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/13/resume-jurnal-generating-event-sequence-based-test-cases-using-gui-runtime-state-feedback/#respond" title="Comment on Resume Jurnal : Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback">0 comment</a></span>
					</div>
					<div class="post-content">
								<p>Berikut merupakan hasil resume saya tentang jurnal tersebut, jurnal tersebut bisa di download <a href="http://ieeexplore.ieee.org/Xplore/login.jsp?url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F32%2F5401361%2F05306073.pdf%3Farnumber%3D5306073&authDecision=-203">disini.</a></p>
<p><strong>Title</strong></p>
<p style="text-align: justify">Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback</p>
<p><strong>Authors</strong></p>
<p style="text-align: justify">Xun Yuan, Student Member, IEEE, and Atif M. Memon, Member, IEEE</p>
<p><strong>Abstract</strong></p>
<p style="text-align: justify">Makalah ini menyajikan teknik model-driven yang sepenuhnya otomatis untuk menghasilkan uji kasus untuk antarmuka pengguna grafis (GUI). Teknik ini menggunakan feedback-based dari pelaksanaan sebuah ” seed test suite,” yang dihasilkan secara otomatis menggunakan sebuah acara model interaksi grafik yang ada struktural dari GUI. Selama pelaksanaannya, efek runtime dari setiap peristiwa GUI pada semua interaksi titik-titik lain Event Semantic Interaction(ESI), yang digunakan secara otomatis menghasilkan uji kasus baru. Dua studi pada delapan aplikasi menunjukkan bahwa teknik feedback-based :<br>
1) mampu secara signifikan meningkatkan teknik yang sudah ada dan membantu mengidentifikasi masalah serius dalam perangkat lunak dan<br>
2) hubungan ESI ditangkap melalui hasil test suite GUI state yang paling sering mendeteksi kesalahan lebih dari kode ,event, dan mitra acara-interaksi-cakupan setara.
</p>
<p><strong>Introduction</strong></p>
<p style="text-align: justify">AUTOMATED test case generation (ATCG) telah menjadi semakin populer karena potensinya untuk mengurangi biaya pengujian dan meningkatkan kualitas perangkat lunak [<a rel="nofollow" href="http://www.amazon.com/Automated-Software-Testing-Introduction-Performance/dp/0201432870">1</a>]. Pendekatan yang umum digunakan untuk ATCG adalah untuk menciptakan model abstrak (misalnya, negara model mesin [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=614080">2</a>], [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=885865">3</a>] dan model acara aliran [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?isNumber=32934&arNumber=1542069&isnumber=32934&arnumber=1542069">4</a>]) dari aplikasi yang sedang diuji (AUT) dan menggunakan model untuk menghasilkan uji kasus.</p>
<p style="text-align: justify">Beberapa peneliti telah mengakui bahwa tugas-tugas ini dapat dibantu dengan memanfaatkan hasil eksekusi dari beberapa uji kasus yang ada. Akibatnya, mereka telah mengembangkan teknik-teknik umpan balik berbasis otomatis untuk menambah model [<a href="http://www.cs.umd.edu/~atif/papers/YuanMemonICSE2007-abstract.html">5</a>], [<a href="http://www.cs.washington.edu/homes/mernst/pubs/testgen-ase2006.pdf">6</a>], [<a href="http://portal.acm.org/citation.cfm?id=1149882">7</a>], <a href="http://portal.acm.org/citation.cfm?id=226158&dl=ACM&coll=DL&CFID=110739056&CFTOKEN=79657253">[8]</a>, <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=624304">[9]</a>, [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=57624">10</a>], [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=988709">11</a>], [<a href="http://portal.acm.org/citation.cfm?id=566191">12</a>], [<a href="http://portal.acm.org/citation.cfm?id=291252.288321">13</a>], [<a href="http://www.computer.org/portal/web/csdl/doi/10.1109/TSE.1976.233818">14</a>]. Teknik ini memerlukan test case awal / suite yang akan dibuat, baik secara manual maupun otomatis, dan dijalankan pada perangkat lunak.</p>
<p style="text-align: justify">Makalah ini menyajikan suatu teknik umpan balik berbasis baru untuk pengujian otomatis dari antarmuka pengguna grafis (GUI). Akhirnya, pengujian GUI ini sangat penting karena GUI digunakan sebagai depan berakhir untuk aplikasi perangkat lunak dan merupakan sebanyak setengah dari kode perangkat lunak [<a href="http://portal.acm.org/citation.cfm?id=122488.122491">16</a>]. Sebuah isnecessary GUI yang tepat untuk eksekusi bebas masalah dasar “logika bisnis” aplikasi <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=614080">[2]</a>, <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=885865">[3]</a>, [<a href="http://portal.acm.org/citation.cfm?id=1122702.1122704">17</a>]</p>
<p style="text-align: justify">Peneliti mencatat bahwa penggunaan model perangkat lunak untuk menghasilkan urutan peristiwa (perintah, panggilan metode, dan masukan data) untuk menguji perangkat lunak bukanlah hal baru. Banyak peneliti telah mengembangkan teknik-teknik yang menggunakan model mesin negara [<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.119.2448&rep=rep1&type=pdf">18</a>], [<a href="http://www.t-vec.com/download/sl2tvec_slick.pdf">19</a>], [<a href="http://portal.acm.org/citation.cfm?id=196092.196088">20</a>], [<a href="http://portal.acm.org/citation.cfm?id=96172">21</a>], [22], tata bahasa [23], [24], [25], AI perencanaan [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=908959">26</a>], [27 ], algoritma genetika [28], model probabilistik [29], diagram arsitektur [30], dan spesifikasi [31] untuk menghasilkan urutan tersebut. Semua teknik ini berguna dalam bahwa mereka dapat digunakan untuk menghasilkan berbagai jenis kasus uji untuk domain yang berbeda. Semuanya didasarkan pada model yang dibuat secara manual.</p>
<p style="text-align: justify">Fokus penelitian pada peningkatan model yang sudah ada (dalam kasus ini, model diperoleh secara otomatis) melalui uji Komentar eksekusi. Peneliti merasa bahwa pendekatan ini dapat digunakan untuk model berbasis teknik lain yang disebutkan di atas-model-model lainnya juga dapat ditingkatkan dengan perangkat lunak dan umpan balik pelaksanaan uji eksekusi.</p>
<p><strong>Method and Materials</strong></p>
<p style="text-align: justify">Seluruh proses ini, termasuk script yang diperlukan untuk mengatur, melaksanakan, dan meruntuhkan uji kasus, telah diimplementasikan dan mengeksekusi tanpa campur tangan manusia. Dua penelitian independen telah dilakukan pada delapan aplikasi Java berbasis GUI untuk mengevaluasi dan memahami pendekatan baru ini. Dalam laporan awal karya ini <a href="http://www.cs.umd.edu/~atif/papers/YuanMemonICSE2007-abstract.html">[5]</a>, kami menjelaskan studi pertama, yang menggunakan empat aplikasi diuji dengan baik dan populer download dari SourceForge, penelitian menunjukkan bahwa teknik umpan balik yang berbasis meningkatkan teknik yang sudah ada dengan biaya tambahan sedikit.</p>
<p style="text-align: justify">Karya ini berfokus pada kelas GUI yang menerima kejadian diskrit dilakukan oleh single user, peristiwa yang deterministik, yaitu, hasil mereka benar-benar diprediksi. Ada dua study yang dibahas disini :</p>
<p style="text-align: justify"><strong>a.	STUDY 1: EVALUATING THE FEEDBACK-BASED TECHNIQUE ON FIELDED APPLICATIONS</strong></p>
<p style="text-align: justify">uji kasus yang diperoleh dari algoritma GenTestCases dimodifikasi dapat dihasilkan dan dijalankan secara otomatis pada GUI. Satu-satunya bagian tidak tersedia merupakan peramal tes, mekanisme yang menentukan apakah suatu AUT dieksekusi dengan baik untuk kasus uji. Dalam studi pertama, AUT itu dianggap telah lulus ujian jika tidak “crash” (menghentikan tiba-tiba atau membuang pengecualian tidak tertangkap) selama eksekusi ujian itu, jika tidak, itu gagal. crash tersebut dapat dideteksi secara otomatis oleh script yang digunakan untuk melaksanakan uji kasus.<br>
Untuk langkah-langkahnya secara garis besar seperti berikut :<br>
LANGKAH 1: Pemilihan aplikasi subjek<br>
LANGKAH 2: Generasi EIG (Event Interaction Graphs) dan suite benih uji<br>
LANGKAH 3: Pelaksanaan uji benih suite<br>
LANGKAH 4: Generasi dari ESIG (EVENT SEMANTIC INTERACTION GRAPH)<br>
LANGKAH 5: Pelaksanaan uji kasus
</p>
<p style="text-align: justify">Kami secara manual melakukan verifikasi bahwa kesalahan tidak diperkenalkan oleh perbaikan bug kami LANGKAH 4. Hasil penelitian menunjukkan bahwa uji kasus ESIG berbasis membantu untuk mendeteksi kesalahan yang tidak terdeteksi oleh teknik sebelumnya</p>
<p style="text-align: justify"><strong>b.	STUDY 2: DIGGING DEEPER VIA SEEDED FAULTS AND IN-HOUSE APPLICATIONS</strong></p>
<p style="text-align: justify">Meskipun studi sebelumnya menunjukkan kegunaan dari teknik ESIG berbasis, juga mengangkat beberapa pertanyaan penting. Satu pertanyaan mendasar yang terlintas dalam pikiran berkaitan dengan penyebab dari efektifitas menambahkan, yaitu, “Apakah efektivitas menambahkan kasus uji insidental peristiwa, interaksi acara, dan garis-of-kode yang uji kasus ESI penutup dan panjang mereka, atau apakah benar-benar karena pengujian ditargetkan hubungan ESI diidentifikasi “?<br>
Pertanyaan ini akan dijawab dengan memilih empat aplikasi berbasis GUI pretested, dan menghasilkan dan melaksanakan dua arah EIG-based dan tiga-cara tes ESIG suite berbasis pada mereka.
</p>
<p style="text-align: justify">Kami akan menghasilkan suite pengujian tambahan yang mirip dengan ESIG berbasis suite dalam hal karakteristik tersebut dan setidaknya tiga-cara berinteraksi, dan membandingkan efektivitas deteksi kesalahan mereka. Efektivitas deteksi kesalahan akan diukur pada basis per-test-suite dalam hal jumlah kesalahan terdeteksi. Kami juga akan mempelajari kesalahan, penentuan alasan mengapa sebagian dari mereka tetap tidak terdeteksi dengan teknik kami.</p>
<p><strong>Result</strong></p>
<p style="text-align: justify">Makalah ini menyajikan suatu teknik otomatis yang baru untuk menguji interaksi antara peristiwa multiway GUI. Teknik ini didasarkan pada analisis umpan balik yang diperoleh dari runtime state widget GUI. Sebuah  test suite digunakan untuk koleksi umpan balik. Teknik ini ditunjukkan melalui dua studi independen atas delapan aplikasi perangkat lunak. Hasil penelitian pertama menunjukkan bahwa uji kasus dihasilkan menggunakan feedback itu berguna dalam mendeteksi kesalahan serius dan relevan dalam aplikasi. Studi kedua membandingkan test suite ESIG berbasis suite EIGbased serupa. Hal ini menunjukkan bahwa efektivitas ditambahkan adalah karena sasaran pengujian hubungan ESI diidentifikasi, bukan efek samping insidental dari ukuran suite, maupun acara tambahan dan kode yang mencakup.</p>
<p style="text-align: justify">Analisis yang dibahas pada bagian method memberikan pemahaman yang lebih dalam hubungan antara peristiwa GUI nyata dan kode yang mendasari dalam aplikasi GUI menerjunkan. Hal ini dapat menyebabkan teknik-teknik baru yang menggabungkan analisis dinamik GUI dan analisis statik dari kode event handler. Sebagai contoh, kode untuk acara istimewa dapat diberikan kepada mesin analisis statis yang dapat memeriksa kode untuk interaksi mungkin yang hanya terlihat pada tingkat kode, misalnya, hubungan data-flow.</p>
<p><strong>Discussion and Recommendations</strong></p>
<p style="text-align: justify">kami ingin memeriksa mengapa beberapa kesalahan tidak terdeteksi. Kami secara manual memeriksa setiap kesalahan dan mencoba menemukan cara-cara manual mewujudkan kesalahan sebagai afailure. Kami menentukan bahwa :</p>
<p style="text-align: justify">1. beberapa kesalahan itu, pada kenyataannya, diwujudkan sebagai kegagalan di GUI tapi oracle tes otomatis kami tidak mampu memeriksa bagian-bagian dari GUI,</p>
<p>2. beberapa kesalahan yang disebabkan kegagalan dalam output non-GUI, yang kita tidak bisa mendeteksi,</p>
<p>3.beberapa kesalahan terdeteksi membutuhkan urutan lebih lama,</p>
<p>4. efek dari beberapa kesalahan yang bertopeng dengan kode event handler bahkan sebelum oracle uji kami bisa mendeteksi itu,</p>
<p>5. beberapa kesalahan jatuh kesalahan mereka sesuai versi unggulan
</p>
<p style="text-align: justify">Penelitian ini dikendalikan menunjukkan bahwa ESI secara otomatis mengidentifikasi hubungan antara peristiwa menghasilkan suite tes yang mendeteksi kesalahan lebih dari kode mereka, acara, dan mitra acara-interaksi-cakupan setara. Selain itu, kami melihat bahwa beberapa kesalahan-kesalahan kita tetap tidak terjawab karena keterbatasan terdeteksi dengan tes otomatis oracle GUIbased kami, dan lain-lain yang diperlukan urutan bahkan lebih lama.</p>
<p><strong>References :</strong></p>
<p style="text-align: justify">Xun Yuan, Atif M. Memon,” <a href="http://ieeexplore.ieee.org/Xplore/login.jsp?url=http%3A%2F%2Fieeexplore.ieee.org%2Fiel5%2F32%2F5401361%2F05306073.pdf%3Farnumber%3D5306073&authDecision=-203">Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback</a> ”, IEEE Transactions on Software Engineering, vol. 36, no. 1, pp. 83, JANUARY/FEBRUARY 2010</p>
<p>Semoga bermanfaat bagi rekanz ^^b</p>
					</div>
					<span class="post-separator"></span>
				</div>
									<div class="post" id="post-44">
					<h2 class="post-title">
						<a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/12/resume-jurnal-event-handler-based-coverage-for-gui-testing/" rel="bookmark" title="Permanent Link to Resume Jurnal : Event Handler-Based Coverage for GUI Testing">Resume Jurnal : Event Handler-Based Coverage for GUI Testing</a>
					</h2>
					<div class="post-info">
						<span class="post-date">November 12, 2010</span>
						<span class="post-comments"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/12/resume-jurnal-event-handler-based-coverage-for-gui-testing/#respond" title="Comment on Resume Jurnal : Event Handler-Based Coverage for GUI Testing">0 comment</a></span>
					</div>
					<div class="post-content">
								<p>Berikut merupakan hasil resume saya tentang jurnal tersebut, jurnal tersebut bisa di download <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5562978">disini.</a></p>
<p><strong>Title</strong></p>
<p>Event Handler-Based Coverage for GUI Testing</p>
<p><strong>Authors</strong></p>
<p>Lei Zhao, Kai-Yuan Cai, Department of Automatic Control, Beijing University of Aeronautics and Astronautics</p>
<p><strong>Abstract</strong></p>
<p style="text-align: justify">Pengujian GUI merupakan masalah penting dan sulit. Salah satu kesulitan dalam pengujian GUI adalah bahwa domain input dari suatu aplikasi GUI non-sepele sangat besar atau tak terbatas. Hal ini diperlukan untuk memperkenalkan beberapa kriteria cakupan untuk membantu orang memilih kasus uji dari domain input dari aplikasi GUI. Dalam tulisan ini, kami mengusulkan sebuah kriteria acara cakupan handler untuk pengujian berbasis GUI. Hal ini mengharuskan semua event handler dan interaksi data antara mereka yang akan dibahas. Percobaan dalam makalah ini menunjukkan bahwa kriteria cakupan yang diusulkan adalah efektif dalam memilih kasus uji dari kolam uji.</p>
<p><strong>Introduction</strong></p>
<p style="text-align: justify">Dalam tulisan ini, pengujian GUI berarti pengujian aplikasi perangkat lunak GUI (atau GUI aplikasi), termasuk uji fungsi GUI ‘dan struktur, serta kode yang mendasari di balik GUI.</p>
<p style="text-align: justify">Beberapa penelitian tentang uji generasi GUI telah dilaporkan dalam literatur. Memon et al. uji pendekatan generasi diusulkan berdasarkan grafik acara-aliran dan perencanaan untuk menghasilkan GUI uji kasus [<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.103.4645&rep=rep1&type=pdf">14</a>]. Dalam pendekatan ini, perencanaan digunakan dalam pencarian jalan dalam grafik event-aliran dari aplikasi yang sedang diuji (AUT). Jalur yang dihasilkan digunakan sebagai uji kasus dalam pengujian GUI. Dalam [<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.86.7748&rep=rep1&type=pdf">10</a>], kasus uji yang dihasilkan oleh traversal grafik acara-aliran. Dalam karya White et al. [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=989458">15</a>] dan Belli [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=989456">1</a>], model negara yang terbatas mesin dibuat untuk menggambarkan interaksi antara pengguna dan AUT tersebut. Kemudian uji kasus dihasilkan berdasarkan model mesin negara yang terbatas.</p>
<p style="text-align: justify">Cakupan kriteria adalah salah satu masalah utama dalam pengujian perangkat lunak. Mereka dapat digunakan untuk menentukan apakah aplikasi yang cukup diuji. Mereka juga dapat digunakan untuk memandu orang untuk menghasilkan uji kasus atau mengurangi test suite [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=199633">18</a>]. Banyak uji kriteria cakupan telah dikembangkan, seperti cakupan laporan, cakupan jalur, cakupan aliran data, dan sebagainya [<a href="http://portal.acm.org/citation.cfm?id=267580.267590">17</a>].</p>
<p style="text-align: justify">Dalam tulisan ini, kami mengusulkan sebuah kriteria GUI cakupan berdasarkan event handler dalam kode sumber aplikasi GUI. Hal ini berfokus pada hubungan data interaksi antara event handler. Percobaan pada dua aplikasi GUI khas dilakukan untuk menunjukkan efektivitas cakupan kriteria yang diusulkan pengendali berbasis dalam pengurangan test suite.</p>
<p><strong>Method and Materials</strong></p>
<p style="text-align: justify">Pada bagian ini, kita pertama-tama akan memperkenalkan beberapa konsep yang terkait dalam pengujian GUI, termasuk peristiwa, event handler dan uji kasus GUI. Kemudian, konsep cakupan handler berbasis diusulkan, yang menggambarkan hubungan berbagi data antara event handler.</p>
<p style="text-align: justify">Dalam Gambar 1, kami menyajikan contoh sederhana aplikasi GUI. Aplikasi ini menghitung nilai sinus atau kosinus dari masukan angka oleh pengguna. Dengan setting “Radian” checkbox atau menonaktifkan, jumlah input dapat diperlakukan sebagai radian atau gelar. Kita bisa mendapatkan nilai sinus atau kosinus jumlah masukan pada kotak masukan dengan Klik tombol “SIN” atau “COS” tombol. Klik tombol “Tentang” tombol akan menampilkan tentang dialog. Event handler lima (bernama h1, h2, h3, h4, dan h5) akan ditampilkan dalam bingkai di sekitar jendela.</p>
<p style="text-align: center"><img src="./Scifo Anggi Yudianto » GUI testing_files/12.gif" alt="A GUI application and its event handlers"><br>
Gambar 1. A GUI application and its event handlers</p>
<p style="text-align: justify">Dua GUI aplikasi yang digunakan dalam percobaan, bernama RichEdit dan TerpSpreadsheet (versi 3.0).</p>
<p style="text-align: justify"><strong>RichEdit</strong> adalah program contoh termasuk dalam Borland C + + Builder © 6. Itu digunakan dalam penelitian sebelumnya dilaporkan dalam [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4020171">3</a>]. kode Its mengandung sekitar 750 baris kode C + + didasarkan pada VCL (Visual Component Library, kerangka kerja berorientasi objek untuk pengembangan aplikasi GUI yang dikembangkan oleh Borland). Ini adalah sebuah aplikasi yang mirip dengan Microsoft WordPad, yang fungsinya meliputi editing, memformat, menyimpan dan mencetak dokumen.</p>
<p style="text-align: justify"><strong>TerpSpreadsheet</strong> adalah aplikasi GUI seperti Excel termasuk dalam suite 3.0 TerpOffice dikembangkan oleh Dr Atif 2004 Memon Teman kelas Spring Rekayasa Perangkat Lunak di Universitas Maryland [7]. Program ini digunakan sebagai aplikasi GUI yang diuji dalam [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=131378">5</a>]. Ini adalah sumber berbasis Java aplikasi spreadsheet yang terbuka dengan sekitar 15.000 baris kode. Fungsinya termasuk manajemen data, menyortir data, menyimpan data, pencetakan data, memproses data, dan generasi grafik.</p>
<p style="text-align: justify">Proses percobaan pada RichEdit ditunjukkan pada Gambar 2. Pertama, kami menghasilkan sebuah kolam uji (Langkah 1 dalam gambar). Kedua, kolam uji diperlakukan sebagai test suite dan dikurangi dengan menggunakan kriteria cakupan yang berbeda (Langkah 2 dalam gambar). Dalam tulisan ini, tiga kriteria cakupan yang dipelajari: cakupan handler berbasis diusulkan (dinotasikan sebagai HC) dan dua kriteria cakupan berdasarkan aktivitas [<a href="http://portal.acm.org/citation.cfm?id=503244">13</a>]: liputan acara (E1) dan acara liputan interaksi (E2). Kemudian, kami membandingkan efektivitas suite uji yang dihasilkan dalam hal kemampuan deteksi mereka kesalahan dan cakupan pernyataan mereka (Langkah 3 dan Langkah 4 dalam Gambar 4).</p>
<p style="text-align: center"><img src="./Scifo Anggi Yudianto » GUI testing_files/22.gif" alt="Proses eksperimen"><br>
Gambar 2. Proses eksperimen</p>
<p style="text-align: justify">Proses percobaan pada TerpSpreadsheet mirip dengan yang ditunjukkan pada Gambar 2, kecuali bahwa kolam uji TerpSpreadsheet di-download dari [8], yang juga digunakan dalam [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4378345">6</a>]. Kolam uji berisi 1.000 kasus uji. Kasus-kasus uji dihasilkan oleh traversal dalam grafik event-aliran aplikasi [<a href="http://portal.acm.org/citation.cfm?id=1062999">10</a>].</p>
<p><strong>Result</strong></p>
<p style="text-align: justify">Dalam tulisan ini, kami juga menggunakan cakupan pernyataan sebagai ukuran efektivitas suite uji. Sebuah test suite yang mencakup laporan lebih mungkin mampu membawa orang keyakinan yang lebih tinggi pada keandalan dari aplikasi perangkat lunak [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=199633">18</a>]. Umumnya, kita dapat mengatakan bahwa test suite yang baik harus dapat mencakup sebagai pernyataan yang lebih mungkin.</p>
<p style="text-align: justify">Meskipun jumlah kesalahan yang terdeteksi per kasus uji / peristiwa TE1 lebih tinggi dari TE2 dan THC, kriteria cakupan acara (E1) tidak cukup dalam pengujian. Kemampuan deteksi kesalahan TE1 terlalu rendah. Sebagai contoh, pada percobaan TerpSpreadsheet, kurang dari 50% kesalahan dapat dideteksi oleh TE1.</p>
<p style="text-align: justify">Dengan mempertimbangkan baik ukuran dan kemampuan deteksi kesalahan, THC adalah yang terbaik di kedua dari dua percobaan. Hal ini dapat mendeteksi lebih dari 90% dari cacat menggunakan kasus uji jauh lebih sedikit dibandingkan dengan kolam pengujian awal. Jadi, pengendali berbasis kriteria yang diusulkan coverage handler-base coverage (HC) adalah pilihan yang baik dalam pengujian GUI.</p>
<p><strong>Discussion and Recommendations</strong></p>
<p style="text-align: justify">Event handler berbasis cakupan kriteria yang diusulkan dalam makalah ini memiliki keuntungan sebagai berikut:<br>
•	Hal ini dapat digunakan tanpa melaksanakan uji kasus. Informasi cakupan dapat diperoleh dengan menganalisis kode sumber dan uji kasus. Tidak instrumentasi kode sumber yang terlibat.<br>
•	Jumlah persyaratan cakupan yang dibutuhkan oleh mereka lebih kecil dari kriteria cakupan berdasarkan aktivitas. Umumnya, persyaratan cakupan lebih sedikit berarti test suite yang lebih kecil. Pada saat yang sama, kesalahan deteksi kemampuan suite uji dikurangi dengan cakupan kriteria yang diusulkan relatif tinggi.</p>
<p style="text-align: justify">Kelemahan dari cakupan yang diusulkan juga jelas, seperti<br>
•	Tidak memperhitungkan kode di perpustakaan. Beberapa interaksi data yang tercantum dalam perpustakaan mungkin akan terjawab dalam pengujian.<br>
•	Kode analisis diperlukan, yang mungkin melibatkan biaya lebih tinggi dari nilai berdasarkan aktivitas.</p>
<p style="text-align: justify">Tulisan ini hanya sebuah studi pendahuluan pada jangkauan event berbasis. Banyak pekerjaan yang masih harus dilakukan di masa depan. Sebagai contoh,</p>
<p style="text-align: justify">(1)	Kriteria cakupan yang mempelajari cakupan urutan handler panjang-n definisi-digunakan harus didefinisikan,<br>
(2)	Algoritma menghasilkan kasus uji berdasarkan kriteria cakupan yang diusulkan harus dikembangkan,<br>
(3)	Metode yang dapat studi kelayakan sepasang handler definisi-digunakan harus diusulkan.</p>
<p><strong>References :</strong></p>
<p style="text-align: justify">Lei Zhao, Kai-Yuan Cai, “<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5562978"><em>Event Handler-Based Coverage for GUI testing</em>”</a>, in International Conference on Quality Software, 2010</p>
<p>Semoga bermanfaat bagi rekanz ^^b</p>
					</div>
					<span class="post-separator"></span>
				</div>
									<div class="post" id="post-37">
					<h2 class="post-title">
						<a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/12/resume-jurnal-a-framework-for-gui-testing-based-on-use-case-design/" rel="bookmark" title="Permanent Link to Resume Jurnal : A Framework for GUI  Testing based on Use Case Design">Resume Jurnal : A Framework for GUI  Testing based on Use Case Design</a>
					</h2>
					<div class="post-info">
						<span class="post-date">November 12, 2010</span>
						<span class="post-comments"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/12/resume-jurnal-a-framework-for-gui-testing-based-on-use-case-design/#respond" title="Comment on Resume Jurnal : A Framework for GUI  Testing based on Use Case Design">0 comment</a></span>
					</div>
					<div class="post-content">
								<p>Berikut merupakan hasil resume saya tentang jurnal tersebut, jurnal tersebut bisa di download <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5463656">disini.</a></p>
<p><strong>Title</strong></p>
<p>A Framework for GUI  Testing based on Use Case Design</p>
<p><strong>Authors</strong></p>
<p style="text-align: justify">Cristiano Bertolini and Alexandre Mota, Center of Informatics, Federal University of Pernambuco, Brazil</p>
<p><strong>Abstract</strong></p>
<p style="text-align: justify">GUI Hari ini tidak bersifat eksklusif terhadap desktop dan aplikasi web. Hal tersebut dapat ditemukan dalam berbagai sistem yang tertanam luas seperti telepon selular, TV, mobil, dll GUI pengujian merupakan pendekatan muncul untuk menjamin kualitas perangkat lunak. Dalam tulisan ini, kami menunjukkan bagaimana untuk mengevaluasi beberapa teknik pengujian GUI dan pentingnya eksperimen dikontrol untuk memiliki keyakinan statistik. Selain itu, karena perubahan desain GUI sering selama proses pengembangan, uji kasus perlu diupdate juga. Oleh karena itu, kami juga mengusulkan kerangka umum untuk rancangan kasus GUI menguji dan generasi berdasarkan pengujian model-based dan menangkap-replay GUI tools. Kerangka ini mudah diperluas untuk mendukung algoritma yang berbeda generasi uji kasus dan bahasa script. Hal ini juga memungkinkan seseorang untuk menjelajahi kebutuhan fungsional maupun non-fungsional, seperti kegunaan, aksesibilitas, kehandalan, dan sebagainya.</p>
<p><strong>Introduction</strong></p>
<p style="text-align: justify">pengujian GUI menjadi sangat populer dan beberapa alat sedang dikembangkan dengan tujuan untuk mengidentifikasi bug dalam sistem internal dari GUI maupun di GUI itu sendiri [2, 17, 30]. Biasanya, alat-alat kerja dengan pengujian model berbasis [24, 29] dan model pemeriksaan [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5368109">7</a>, 25] pendekatan.</p>
<p style="text-align: justify">Dalam tulisan ini kami menyajikan sebuah kerangka kerja yang mencakup cara extensible dan umum untuk merancang persyaratan GUI dan generasi uji kasus (Bagian 4), dan pedoman untuk mengevaluasi teknik pengujian kotak hitam statistik (Bagian 5). Kami menangani kerangka yang diusulkan dengan otomatisasi tes dan pemeliharaan untuk pengujian GUI. Hal ini dapat bekerja dengan berbagai jenis kebutuhan. Idenya adalah untuk menciptakan kasus digunakan dalam layar CNL yang menangkap karakteristik dan perilaku. Setelah itu, kasus ini menggunakan dipetakan ke dalam komponen GUI untuk menghasilkan skrip tes otomatis.</p>
<p style="text-align: justify">Pada bagian ini kami menyajikan sebuah kerangka kerja GUI untuk membantu penciptaan deskripsi dan skrip tes berbasis pada tujuan kasus uji GUI generasi. Gambar 1 menunjukkan garis besar seperti kerangka kerja.</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/11.gif" alt="gui framework"></p>
<p style="text-align: center">Gambar 1. <em>GUI</em> Framework</p>
<p><strong>Method and Materials</strong></p>
<p style="text-align: justify">Pada dasarnya, dalam desain eksperimen [21] kami memiliki 3 kegiatan: perencanaan, evaluasi dan analisis. Gambar 2 menunjukkan sebuah pedoman yang kita gunakan dalam percobaan terkontrol kami. Pedoman ini disusun oleh tugas-tugas berikut:</p>
<p style="text-align: justify">•	Tentukan tujuan utama dan hipotesis: itu adalah penting bagi negara tepat apa adalah tujuan percobaan dan hipotesis percobaan harus mengkonfirmasi atau menolak.<br>
•	GQM: untuk mencapai tujuan percobaan kita mendefinisikan pertanyaan dan metrik untuk tujuan utama berdasarkan pendekatan (GQM) tujuan-pertanyaan-metrik [23]<br>
•	Eksperimental bahan: kita mencirikan subjek penelitian dengan mendefinisikan bahan yang digunakan dalam percobaan. Artinya, benda-benda (hardware, aplikasi, dll) yang perlakuan akan diterapkan.<br>
•	Pengobatan dan rancangan percobaan: kita juga perlu mendefinisikan faktor (variabel kepentingan yang ingin kita amati) dan struktur percobaan (faktorial, pemblokiran, replikasi, dll).<br>
•	Melakukan percobaan dan mengumpulkan data: setelah perencanaan percobaan kita harus menjalankan percobaan.<br>
•	Analisa varians: ia mengamati varians dua (atau lebih) mengamati variabel dan ini berguna untuk tujuan perbandingan. Dalam penelitian kami, kami menggunakan ini untuk membandingkan teknik pengujian GUI yang dianalisis.<br>
•	Analisis Pengaruh variabel-variabel: ia mengamati efek dari variabel yang digunakan dalam penelitian ini.</p>
<p style="text-align: center"><img src="./Scifo Anggi Yudianto » GUI testing_files/21.gif" alt="pedoman eksperimen"><br>
Gambar 2. Pedoman dalam Desain Eksperimen.</p>
<p style="text-align: justify">Kami melakukan eksperimen direncanakan dan dikendalikan untuk melengkapi informasi yang telah kita pelajari dari Dengan melihat pada [<a href="http://scifoanggi.students-blog.undip.ac.id/tag/gui-testing/www.iist.unu.edu/~cbertolini/papers/paper144_ICST2009.pdf">9</a>]. Kami memilih untuk melakukan analisis lebih dalam tentang teknik pengujian GUI dengan tingkat tertinggi otomatisasi dan menentukan teknik lebih baik. Namun kita hanya mengevaluasi teknik GUI dalam konteks telepon seluler aplikasi. Ini berarti bahwa kerangka yang lebih fleksibel kita sangat berguna untuk memperkenalkan teknik baru GUI pengujian dan menerapkan teknik ini dalam konteks lain seperti aplikasi web dan desktop.</p>
<p><strong>Result</strong></p>
<p style="text-align: justify">Dari Tabel 1 kita dapat mengamati bahwa hampir semua faktor dan interaksinya (ditandai dengan * antara faktor), probabilitas menolak hipotesis null diterima (asumsi nilai p lebih besar dari 5%). Dengan demikian, kita dapat menyimpulkan bahwa dalam kasus seperti itu, faktor-faktor serta interaksi perusahaan tidak mempunyai pengaruh dalam variabel respon kita.</p>
<p style="text-align: center"><img src="./Scifo Anggi Yudianto » GUI testing_files/31.gif" alt="tabel ANOVA"><br>
Tabel 1. Tabel ANOVA untuk semua efek</p>
<p style="text-align: justify">Seperti yang bisa kita lihat pada Tabel 1, mirip dengan kesimpulan pekerjaan kami sebelumnya [<a href="http://scifoanggi.students-blog.undip.ac.id/tag/gui-testing/www.iist.unu.edu/~cbertolini/papers/icst2010.pdf">8</a>], kami menunjukkan bahwa BxT lebih baik dari DH dan SizeTC dan parameter Teknik dan kombinasi Didorong * SizeTC memiliki efek signifikan pada waktu untuk menemukan bug. Hasil lengkap dapat ditemukan di [<a href="http://scifoanggi.students-blog.undip.ac.id/tag/gui-testing/www.iist.unu.edu/~cbertolini/papers/icst2010.pdf">8</a>].</p>
<p style="text-align: justify">Keuntungan utama dari kerangka kerja kami adalah: cara mudah untuk menggambarkan layar dan generasi skrip tes otomatis. Juga, kita dapat memperpanjang pemetaan dalam rangka mendukung bahasa script yang berbeda. Keuntungan langsung adalah untuk mendukung berbagai jenis aplikasi, seperti web, desktop, mobile, dll Salah satu kelemahan dari kerangka kerja kami adalah tentang ramalan. Saat ini, pengguna harus menerapkan atau menggunakan oracle yang diberikan terkait dengan pelaksanaan script. Namun, dalam kasus penggunaan kita memiliki kolom yang disebut Sistem Respon yang berarti hasil yang diharapkan dari setiap langkah.</p>
<p><strong>Discussion and Recommendations</strong></p>
<p style="text-align: justify">kerangka kerja kami adalah solusi umum untuk desain GUI dan generasi uji kasus dan dapat diperpanjang untuk setiap jenis aplikasi. Model mudah ditulis dalam subset dari bahasa Inggris. Hal ini membebaskan pengguna untuk mengetahui setiap formalisme spesifikasi.</p>
<p style="text-align: justify">Untuk meningkatkan teknik-teknik yang diusulkan dalam [<a href="http://scifoanggi.students-blog.undip.ac.id/tag/gui-testing/www.iist.unu.edu/~cbertolini/papers/paper144_ICST2009.pdf">9</a>] kita dapat menggunakan model untuk meningkatkan eksplorasi untuk mendeteksi crash melalui eksplorasi dipandu. Juga sebagai pekerjaan di masa depan, kami berharap dapat mengintegrasikan pendekatan untuk melakukan pengujian GUI, yang meliputi aspek-aspek yang berbeda dari GUI dan menyediakan kerangka extensible untuk mengevaluasi teknik-teknik baru GUI pengujian.</p>
<p style="text-align: justify">Karya lain masa depan kita mempertimbangkan adalah bagaimana untuk mengotomatisasi ekstraksi kasus digunakan dari sistem dan kemudian menghasilkan dan melaksanakan tes ini dalam sistem. Namun, kami percaya bahwa pendekatan yang lebih efisien adalah dengan menggunakan ekstraksi model untuk tes otomatis yang dapat meningkatkan keandalan dan untuk mendeteksi crash pada aplikasi.</p>
<p><strong>References :</strong></p>
<p>Cristiano Bertolini, Alexandre Mota, “<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=5463656">A Framework for GUI testing based on Use Case Design</a>”,in Third International Conference on Software Testing, Verification, and Validation Workshops, 2010</p>
<p>Semoga bermanfaat bagi rekanz ^^b</p>
					</div>
					<span class="post-separator"></span>
				</div>
									<div class="post" id="post-24">
					<h2 class="post-title">
						<a href="http://scifoanggi.students-blog.undip.ac.id/2010/10/04/resume-jurnal-a-dynamic-partitioning-approach-for-gui-testing/" rel="bookmark" title="Permanent Link to Resume Jurnal : A Dynamic Partitioning Approach for GUI Testing">Resume Jurnal : A Dynamic Partitioning Approach for GUI Testing</a>
					</h2>
					<div class="post-info">
						<span class="post-date">October 4, 2010</span>
						<span class="post-comments"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/10/04/resume-jurnal-a-dynamic-partitioning-approach-for-gui-testing/#respond" title="Comment on Resume Jurnal : A Dynamic Partitioning Approach for GUI Testing">0 comment</a></span>
					</div>
					<div class="post-content">
								<p>Berikut merupakan hasil resume saya tentang jurnal tersebut, jurnal tersebut bisa di download <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4020171">disini.</a></p>
<p><strong>Title</strong></p>
<p style="text-align: justify">A Dynamic Partitioning Approach for GUI Testing</p>
<p style="text-align: left">
</p><p><strong>Authors</strong></p>
<p style="text-align: justify">Kai-Yuan Cai, Lei Zhao and Feng Wang, Department of Automatic Control, Beijing University of Aeronautics and Astronautics</p>
<p style="text-align: left">
</p><p><strong>Abstract</strong></p>
<p style="text-align: justify">Penelitian sebelumnya pada pengujian <em>Graphical User Interface(GUI)</em> yang terutama berkaitan dengan cara menetapkan atau menghasilkan kasus uji <em>GUI</em>. Masalah bagaimana menggunakan uji kasus dihasilkan <em>GUI</em> atau tindakan primitif jarang dibahas. Dalam tulisan ini kami mengusulkan pendekatan partisi dinamis untuk <em>GUI</em> pengujian untuk mengatasi masalah ini. Dalam pendekatan ini, <em>GUI</em> diberikan tindakan primitif yang dinamis dibagi menjadi dua kelas beririsan: satu terdiri dari tindakan primitif diprioritaskan dan yang lainnya non-prioritas yang terdiri.</p>
<p><strong><br>
</strong></p>
<p><strong>Introduction</strong></p>
<p style="text-align: justify">Beberapa pendekatan telah diusulkan untuk pengujian GUI. Yang paling dikenal mungkin adalah menangkap apa yang disebut / Teknik replay [1]. Dalam karya White et al [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=885865">2</a>, <a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=989458">3</a>] dan Belli [<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=989456">4</a>], berbagai tanggung jawab diidentifikasi untuk GUI yang diuji. Setiap tanggung jawab hanyalah respon yang diinginkan untuk pengguna dan dapat ditentukan sebagai urutan interaksi lengkap (CIS) antara pengguna dan aplikasi GUI yang diuji.</p>
<p style="text-align: justify">Dari pekerjaan sebelumnya pengujian GUI, bagaimanapun, kita dapat melihat bahwa uji kasus atau suite uji perhatian hampir pasti atau dihasilkan secara off-line sebelum diterapkan pada GUI yang diuji. Sebuah paradigma implisit sebenarnya diikuti:</p>
<p style="text-align: justify">(1). Test definisi kasus diberikan;</p>
<p style="text-align: justify">(2). sejumlah kecil kasus uji yang dihasilkan untuk membentuk suatu test suite yang diinginkan yang diharapkan untuk mencapai cakupan tes tertentu seperti cakupan peristiwa;</p>
<p style="text-align: justify">(3). Semua kasus uji dalam test suite yang diberikan secara mendalam dilaksanakan dan beberapa uji kasus yang dilakukan lebih dari sekali.</p>
<p style="text-align: justify">
</p><p>Paradigma ini tidak memperhitungkan data pengujian atau informasi GUI kegagalan yang dikumpulkan atau disampaikan selama proses pengujian GUI. Dalam tulisan ini kami memperkenalkan ide partisi dinamis untuk pengujian GUI.</p>
<p><strong><br>
</strong></p>
<p><strong>Method and Materials</strong></p>
<p style="text-align: justify">Aplikasi GUI subyek pertama yang diterapkan dalam percobaan pengujian kami adalah RichEdit, yang merupakan program contoh termasuk dalam Borland C + + Builder 6.0 Demo [9]. Ini terdiri dari 749 baris kode eksekusi dan dapat berjalan di lingkungan Win3.2. Gambar 5.1 menunjukkan antarmuka operasi RichEdit. Operasi dasar ini mencakup: File (Buka, Simpan, Simpan sebagai), Edit (Copy, Cut, Paste), Font (Resize, tipe Set, Set warna) mengeset (Rata, Atur), andHelp.</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/1.gif" alt=""></p>
<p style="text-align: center">Figure 5.1 Operating User Interface of RichEdit<strong> </strong></p>
<p style="text-align: justify">Aplikasi GUI subjek kedua MyIE 3.2, yang merupakan browser tab dengan antarmuka yang dapat disesuaikan [10]. Hal ini didasarkan pada mesin browser Internet Explorer. Banyak fitur yang efisien tambahan yang disediakan dalam MyIE, seperti multi-browsing halaman, operasi tab, jendela iklan filter, menyimpan halaman web cepat, menampilkan alamat IP dan pengaturan server proxy cepat. Gambar 5.2 menunjukkan GUI dari browser. MyIE 3.2 ditulis dalam Visual C + + 6.0 (berdasarkan MFC), terdiri dari 84 kelas, 152 file, dan 49664 baris kode sumber, yang 30.374 baris yang dieksekusi.</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/2.gif" alt=""></p>
<p style="text-align: center">Figure 5.2 Operating User Interface of MyIE 3.2</p>
<p style="text-align: justify">Sebuah platform pengujian dikembangkan untuk mengotomatisasi proses pengujian GUI untuk aplikasi subjek di atas. Gambar 5.3 menunjukkan arsitektur dari platform pengujian, dimana blok perangkat lunak mengacu pada RichEdit atau MyIE 3,2 komponen yang berisi sejumlah cacat disuntikkan.</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/3.gif" alt=""></p>
<p style="text-align: center">Figure 5.3<strong> </strong>Architecture of the Testing Platform</p>
<p>Ada dua percobaan yang dilakukan :</p>
<p>1. Percobaan I</p>
<p style="text-align: justify">Dalam Percobaan I, DP dan pendekatan RD diaplikasikan pada RichEdit aplikasi <em>GUI</em> subjek. Himpunan tindakan primitif terdiri 29 tindakan primitif. Tindakan ini mencakup semua operasi fungsional dasar seperti pemilihan Menu, Button klik, seleksi Teks, dan sebagainya. Penting untuk dicatat bahwa tindakan primitif dapat melakukan lebih dari satu operasi dasar dari RichEdit. “Primitif” berarti bahwa tindakan diperlakukan sebagai terpisahkan selama pengujian. Ini tidak berarti bahwa itu harus satu dasar operasi. Gagasan tindakan primitif harus diinterpretasikan secara luas.</p>
<p>2. Percobaan      II</p>
<p style="text-align: justify">Percobaan II mirip dengan Percobaan I. Namun subjek aplikasi <em>GUI</em> adalah MyIE 3.2. Selanjutnya, himpunan semua tindakan primitif terdiri 353 tindakan secara total. Tindakan ini mencakup sebagian besar operasi fungsional MyIE 3.2. Dalam setiap percobaan pengujian, proses pengujian dihentikan pada 18 cacat dibuang.</p>
<p style="text-align: justify">
</p><p><strong>Result</strong></p>
<p style="text-align: justify">Hasil dari percobaan I bisa dilihat pada table 6.1 sedangkan hasil dari percobaan II bisa dilihat pada table 6.2</p>
<p style="text-align: center">Tabel 6.1 Hasil Percobaan untuk RichEdit</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/4.gif" alt=""></p>
<p style="text-align: center">
</p><p style="text-align: center">Tabel 6.2 Hasil Percobaan untuk MyIE 3.2</p>
<p style="text-align: center"><img class="aligncenter" src="./Scifo Anggi Yudianto » GUI testing_files/5.gif" alt=""></p>
<p>Dari hasil pengujian dua percobaan, kita memiliki pengamatan berikut :</p>
<p>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Pendekatan partisi dinamis secara signifikan dapat mengalahkan pendekatan pengujian acak.</p>
<p>2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Standar deviasi &nbsp;mengukur seberapa stabil pendekatan pengujian berperilaku dalam percobaan pengujian yang berbeda.</p>
<p>3.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Perbedaan utama antara pendekatan RD dan pendekatan DP terletak pada bahwa pendekatan DP mempertimbangkan pengujian data yang dikumpulkan selama pengujian sebagai informasi umpan balik online yang diabaikan dalam pendekatan RD.</p>
<p style="text-align: left">4.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Namun keuntungan dari pendekatan DP atas pendekatan RD mungkin berbeda dengan aplikasi <em>GUI</em> yang diuji.</p>
<p style="text-align: left">
</p><p><strong>Discussion and Recommendations</strong></p>
<p style="text-align: justify">Sebelumnya bekerja pada pengujian GUI yang terutama berkaitan dengan cara menetapkan atau menghasilkan kasus uji GUI. Masalah bagaimana menggunakan uji kasus dihasilkan GUI atau tindakan primitif jarang dibahas. Menurut pendekatan ini diusulkan dalam tulisan ini, GUI diberikan tindakan primitif yang dinamis dibagi menjadi dua kelas beririsan: satu terdiri dari tindakan primitif diprioritaskan dan yang lainnya non-prioritas yang terdiri.</p>
<p style="text-align: justify">Percobaan menguji dua dengan aplikasi GUI nyata menunjukkan bahwa pendekatan partisi dinamis yang diusulkan benar-benar dapat bekerja dalam praktik dan secara signifikan dapat mengungguli pendekatan pengujian acak. Pendekatan partisi dinamis mengadopsi mekanisme umpan balik eksplisit dan baik sesuai dengan filosofi dari perangkat lunak cybernetics yang menggali interaksi antara perangkat lunak dan kontrol. Bagaimana menggabungkan gagasan partisi dinamis ke metode yang ada untuk pengujian GUI dalam daftar karya masa depan.</p>
<p style="text-align: justify">
</p><p><strong>References :</strong></p>
<p style="text-align: justify">Kai-Yuan Cai, Lei Zhao, Feng Wang, “<a href="http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4020171">A Dynamic Partitioning Approach for <em>GUI testing</em></a>”, in <em>Proceedings of the 30th Annual International Computer Software and Applications Conference (COMPSAC)</em>, Vol.2, September 2006</p>
<p style="text-align: justify">
</p><p>Semoga bermanfaat bagi rekanz ^^b</p>
					</div>
					<span class="post-separator"></span>
				</div>
									<div class="post" id="post-8">
					<h2 class="post-title">
						<a href="http://scifoanggi.students-blog.undip.ac.id/2010/09/20/tugas-1-rpl/" rel="bookmark" title="Permanent Link to Tugas 1 RPL">Tugas 1 RPL</a>
					</h2>
					<div class="post-info">
						<span class="post-date">September 20, 2010</span>
						<span class="post-comments"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/09/20/tugas-1-rpl/#respond" title="Comment on Tugas 1 RPL">0 comment</a></span>
					</div>
					<div class="post-content">
								<p>(Versi Editan)</p>
<p>Kelompok 4 &nbsp;&nbsp;&nbsp;&nbsp; : Empirical Software Testing Research</p>
<p>Tema&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : Tes Techniques</p>
<p>Sub Tema&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; : Based on Nature of Application(GUI Testing)</p>
<p>List Jurnal :</p>
<ol></ol>
<ol>
<li>A Dynamic Partitioning Approach for GUI Testing1</li>
<li>A Framework for GUI Testing based on Use Case Design</li>
<li>An Empirical Evaluation of Automated Black-Box Testing Techniques for Crashing GUIs</li>
<li>Call-Stack Coverage for GUI Test Suite Reduction</li>
<li>Event Handler-Based Coverage for GUI Testing</li>
<li>Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback</li>
<li>GUI Testing Techniques Evaluation by Designed Experiments</li>
<li>Hierarchical GUI Test Case Generation Using Automated Planning</li>
<li>On the Test Case Definition for GUI Testing</li>
<li>Relationships Between Test Suites, Faults, and Fault Detection in GUI Testing</li>
<li>Studying the Fault-Detection Effectiveness of GUI Test Cases for Rapidly Evolving Software</li>
<li>Using Probabilistic Model Checking to Evaluate GUI Testing Techniques</li>
</ol>
<ol></ol>
<p>Seluruh jurnal didapat dari www.computer.org</p>
<p>Semoga bermanfaat ^^</p>
					</div>
					<span class="post-separator"></span>
				</div>
													<div id="pagenavi">
										<span class="newer"></span>
					<span class="older"></span>
										<div class="fixed"></div>
				</div>
			</div>
			<!-- END OF POSTS -->
			<div style="font-size:85%;clear:both;text-align:center;margin-top:20px;position:relative;color:#555;">Improve the web with <a href="http://www.inverudio.com/programs/WordPressBlog/NofollowReciprocity.php">Nofollow</a> <em>Reciprocity</em>.</div><div id="footer">
	<div id="footer-left">
		<p>
			powerd by <a href="http://wordpress.org/" title="WordPress">WordPress</a>.
		</p>
	</div>
	<div id="footer-right">
		<p>
			© copyright 2009 Scifo Anggi Yudianto		</p>
		<p>
			Theme <a href="http://pigsky.net/flashy" target="_blank">flashy</a> designed by <a href="http://pigsky.net/" target="_blank">AddoZh</a>.
		</p>
	</div>
</div>
<div id="wp-admin-bar"><div class="padder"><a href="http://students-blog.undip.ac.id/" id="admin-bar-logo">students community</a><ul class="main-nav"><li class="bp-login no-arrow"><a href="http://students-blog.undip.ac.id/wp-login.php?redirect_to=http%3A%2F%2Fstudents-blog.undip.ac.id">Log In</a></li><li id="bp-adminbar-authors-menu"><a href="http://scifoanggi.students-blog.undip.ac.id/">Blog Authors</a><ul class="author-list"><li><a href="http://students-blog.undip.ac.id/members/scifoanggi/"><img src="./Scifo Anggi Yudianto » GUI testing_files/44dece76f2f64e5a9a31c2b4f7cff6a4" alt="Avatar Image" class="avatar user-955-avatar" width="15" height="15"> scifoanggi</a><div class="admin-bar-clear"></div></li></ul></li>
	<li class="align-right" id="bp-adminbar-visitrandom-menu">
		<a href="http://scifoanggi.students-blog.undip.ac.id/tag/gui-testing/#">Visit</a>
		<ul class="random-list">
			<li><a href="http://students-blog.undip.ac.id/members/?random-member">Random Member</a></li>

			
				<li class="alt"><a href="http://students-blog.undip.ac.id/groups/?random-group">Random Group</a></li>

			
			
				<li><a href="http://students-blog.undip.ac.id/blogs/?random-blog">Random Blog</a></li>

			
			<li><a href="http://students-blog.undip.ac.id/links/?random-link">Random Link</a></li>
		</ul>
	</li>

	</ul></div></div><!-- #wp-admin-bar -->

<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/ui.core.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/ui.widget.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/ui.mouse.js"></script>
<script type="text/javascript" src="./Scifo Anggi Yudianto » GUI testing_files/ui.draggable.js"></script>

<!-- Generated in 0.651 seconds. -->

	<!-- END OF FOOTER -->		</div>
		<!-- END OF LEFT -->
		<div id="sidebar">
	<!-- feed -->
			<div class="widget top">
			<h3>Feed</h3>
			<div>
				<a id="feed" href="http://scifoanggi.students-blog.undip.ac.id/feed/" title="feed me">RSS 2.0</a>
								<div class="clear"></div>
			</div>
		</div>
		<!-- show random posts in single page and show recent posts in home page -->
			<div class="widget show_posts">
			<h3>Recent Posts</h3>
			<ul>
				<li><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/14/resume-jurnal-on-the-test-case-definition-for-gui-testing/">Resume jurnal : On the Test Case Definition for GUI Testing</a></li><li><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/14/resume-jurnal-hierarchical-gui-test-case-generation-using-automated-planning/">Resume jurnal : Hierarchical GUI Test Case Generation Using Automated Planning</a></li><li><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/13/resume-jurnal-generating-event-sequence-based-test-cases-using-gui-runtime-state-feedback/">Resume Jurnal : Generating Event Sequence-Based Test Cases Using GUI Runtime State Feedback</a></li><li><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/12/resume-jurnal-event-handler-based-coverage-for-gui-testing/">Resume Jurnal : Event Handler-Based Coverage for GUI Testing</a></li><li><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/12/resume-jurnal-a-framework-for-gui-testing-based-on-use-case-design/">Resume Jurnal : A Framework for GUI  Testing based on Use Case Design</a></li><li><a href="http://scifoanggi.students-blog.undip.ac.id/2010/10/04/resume-jurnal-a-dynamic-partitioning-approach-for-gui-testing/">Resume Jurnal : A Dynamic Partitioning Approach for GUI Testing</a></li><li><a href="http://scifoanggi.students-blog.undip.ac.id/2010/09/20/tugas-1-rpl/">Tugas 1 RPL</a></li>			</ul>
		</div>
					<div id="akismet" class="widget widget_akismet">				<h3>Spam Blocked</h3>                <div id="akismetwrap"><div id="akismetstats"><a id="aka" href="http://akismet.com/" title=""><span id="akismet1"><span id="akismetcount">0</span> <span id="akismetsc">spam comments</span></span> <span id="akismet2"><span id="akismetbb">blocked by</span><br><span id="akismeta">Akismet</span></span></a></div></div> 
			</div>	<div id="categories-3" class="widget widget_categories"><h3>Categories</h3>		<ul>
	<li class="cat-item cat-item-2319"><a href="http://scifoanggi.students-blog.undip.ac.id/category/madis/" title="View all posts filed under Madis">Madis</a>
</li>
	<li class="cat-item cat-item-1998"><a href="http://scifoanggi.students-blog.undip.ac.id/category/rpl/" title="View all posts filed under RPL">RPL</a>
</li>
	<li class="cat-item cat-item-1"><a href="http://scifoanggi.students-blog.undip.ac.id/category/uncategorized/" title="View all posts filed under Uncategorized">Uncategorized</a>
</li>
		</ul>
</div><div id="meta-3" class="widget widget_meta"><h3>Meta</h3>			<ul>
						<li><a href="http://scifoanggi.students-blog.undip.ac.id/wp-login.php">Log in</a></li>
			<li><a href="http://scifoanggi.students-blog.undip.ac.id/feed/" title="Syndicate this site using RSS 2.0">Entries <abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="http://scifoanggi.students-blog.undip.ac.id/comments/feed/" title="The latest comments to all posts in RSS">Comments <abbr title="Really Simple Syndication">RSS</abbr></a></li>
			<li><a href="http://wordpress.org/" title="Powered by WordPress, state-of-the-art semantic personal publishing platform.">WordPress.org</a></li>
						</ul>
</div><div id="calendar-3" class="widget widget_calendar"><h3>Tanggalan</h3><div id="calendar_wrap"><table id="wp-calendar" summary="Calendar">
	<caption>April 2014</caption>
	<thead>
	<tr>
		<th scope="col" title="Monday">M</th>
		<th scope="col" title="Tuesday">T</th>
		<th scope="col" title="Wednesday">W</th>
		<th scope="col" title="Thursday">T</th>
		<th scope="col" title="Friday">F</th>
		<th scope="col" title="Saturday">S</th>
		<th scope="col" title="Sunday">S</th>
	</tr>
	</thead>

	<tfoot>
	<tr>
		<td colspan="3" id="prev"><a href="http://scifoanggi.students-blog.undip.ac.id/2010/11/" title="View posts for November 2010">« Nov</a></td>
		<td class="pad">&nbsp;</td>
		<td colspan="3" id="next" class="pad">&nbsp;</td>
	</tr>
	</tfoot>

	<tbody>
	<tr>
		<td colspan="1" class="pad">&nbsp;</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td>
	</tr>
	<tr>
		<td>7</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td>
	</tr>
	<tr>
		<td>14</td><td>15</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td>
	</tr>
	<tr>
		<td>21</td><td>22</td><td>23</td><td>24</td><td>25</td><td id="today">26</td><td>27</td>
	</tr>
	<tr>
		<td>28</td><td>29</td><td>30</td>
		<td class="pad" colspan="4">&nbsp;</td>
	</tr>
	</tbody>
	</table></div></div>
</div>
<!-- END OF SIDEBAR -->

	</div>
	<!-- END OF MAIN -->
</div>
<!-- END OF CONTENT -->

</body></html>